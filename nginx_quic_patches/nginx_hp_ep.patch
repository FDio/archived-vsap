:100644 100644 9ab06209 c77fca7f M	auto/lib/openssl/conf
:100644 100644 fec7bb83 41ac86f2 M	src/core/ngx_conf_file.c
:100644 100644 85707425 96725486 M	src/core/ngx_output_chain.c
:100644 100644 49e0a8c4 7c9af97d M	src/core/ngx_times.h
:100644 100644 284aafbe 1c6e45ff M	src/event/ngx_event.c
:100644 100644 834e7935 e6a5ae3f M	src/event/quic/ngx_event_quic.c
:100644 100644 2b198ac6 9b271e07 M	src/event/quic/ngx_event_quic_connection.h
:100644 100644 b72d3319 1653a4f5 M	src/event/quic/ngx_event_quic_output.c
:100644 100644 bbf85af9 04847126 M	src/event/quic/ngx_event_quic_protection.c

diff --git a/auto/lib/openssl/conf b/auto/lib/openssl/conf
index 9ab06209..c77fca7f 100644
--- a/auto/lib/openssl/conf
+++ b/auto/lib/openssl/conf
@@ -165,3 +165,6 @@ END
         fi
     fi
 fi
+
+CORE_LIBS="$CORE_LIBS -lIPSec_MB"
+
diff --git a/src/core/ngx_conf_file.c b/src/core/ngx_conf_file.c
index fec7bb83..41ac86f2 100644
--- a/src/core/ngx_conf_file.c
+++ b/src/core/ngx_conf_file.c
@@ -8,7 +8,9 @@
 #include <ngx_config.h>
 #include <ngx_core.h>
 
-#define NGX_CONF_BUFFER  4096
+// #define NGX_CONF_BUFFER  4096
+#define NGX_CONF_BUFFER  2048000 //for the performance tests
+
 
 static ngx_int_t ngx_conf_add_dump(ngx_conf_t *cf, ngx_str_t *filename);
 static ngx_int_t ngx_conf_handler(ngx_conf_t *cf, ngx_int_t last);
diff --git a/src/core/ngx_output_chain.c b/src/core/ngx_output_chain.c
index 85707425..96725486 100644
--- a/src/core/ngx_output_chain.c
+++ b/src/core/ngx_output_chain.c
@@ -100,6 +100,19 @@ ngx_output_chain(ngx_output_chain_ctx_t *ctx, ngx_chain_t *in)
 
             bsize = ngx_buf_size(ctx->in->buf);
 
+            ngx_log_error(NGX_LOG_NOTICE, ctx->pool->log, 0,
+                              "Metrics: size buf in output "
+                              "t:%d r:%d f:%d %p %p-%p %p %O-%O",
+                              ctx->in->buf->temporary,
+                              ctx->in->buf->recycled,
+                              ctx->in->buf->in_file,
+                              ctx->in->buf->start,
+                              ctx->in->buf->pos,
+                              ctx->in->buf->last,
+                              ctx->in->buf->file,
+                              ctx->in->buf->file_pos,
+                              ctx->in->buf->file_last);
+
             if (bsize == 0 && !ngx_buf_special(ctx->in->buf)) {
 
                 ngx_log_error(NGX_LOG_ALERT, ctx->pool->log, 0,
diff --git a/src/core/ngx_times.h b/src/core/ngx_times.h
index 49e0a8c4..7c9af97d 100644
--- a/src/core/ngx_times.h
+++ b/src/core/ngx_times.h
@@ -48,5 +48,4 @@ extern volatile ngx_str_t    ngx_cached_syslog_time;
  */
 extern volatile ngx_msec_t  ngx_current_msec;
 
-
 #endif /* _NGX_TIMES_H_INCLUDED_ */
diff --git a/src/event/ngx_event.c b/src/event/ngx_event.c
index 284aafbe..1c6e45ff 100644
--- a/src/event/ngx_event.c
+++ b/src/event/ngx_event.c
@@ -755,6 +755,8 @@ ngx_event_process_init(ngx_cycle_t *cycle)
     }
 
     c = cycle->connections;
+    ngx_log_error(NGX_LOG_WARN, cycle->log, 0,
+            "cycle->connection_n:%d",cycle->connection_n);
 
     cycle->read_events = ngx_alloc(sizeof(ngx_event_t) * cycle->connection_n,
                                    cycle->log);
@@ -797,10 +799,18 @@ ngx_event_process_init(ngx_cycle_t *cycle)
     cycle->free_connection_n = cycle->connection_n;
 
     /* for each listening socket */
-
+    
+            
     ls = cycle->listening.elts;
     for (i = 0; i < cycle->listening.nelts; i++) {
 
+        ngx_log_error(NGX_LOG_WARN, cycle->log, 0,
+            "cycle->listening.elts[%d]:%d, type:%d, listen:%s:%d",
+            i,ls[i].fd,
+            ls[i].type,
+            inet_ntoa(((struct sockaddr_in*)ls[i].sockaddr)->sin_addr),
+            ntohs(((struct sockaddr_in*)ls[i].sockaddr)->sin_port));
+
 #if (NGX_HAVE_REUSEPORT)
         if (ls[i].reuseport && ls[i].worker != ngx_worker) {
             continue;
@@ -891,6 +901,10 @@ ngx_event_process_init(ngx_cycle_t *cycle)
 
 #if (NGX_QUIC)
         } else if (ls[i].quic) {
+            ngx_log_error(NGX_LOG_WARN, cycle->log, 0,
+                "ls[%d].quic: c->type:%d,c->socket_fd:%d",
+                        i,c->type,c->fd);
+
             rev->handler = ngx_quic_recvmsg;
 #endif
         } else {
diff --git a/src/event/quic/ngx_event_quic.c b/src/event/quic/ngx_event_quic.c
index 834e7935..e6a5ae3f 100644
--- a/src/event/quic/ngx_event_quic.c
+++ b/src/event/quic/ngx_event_quic.c
@@ -1173,9 +1173,9 @@ ngx_quic_handle_frames(ngx_connection_t *c, ngx_quic_header_t *pkt)
             qc->error = pkt->error;
             return NGX_ERROR;
         }
-
+#if 1
         ngx_quic_log_frame(c->log, &frame, 0);
-
+#endif
         c->log->action = "handling frames";
 
         p += len;
diff --git a/src/event/quic/ngx_event_quic_connection.h b/src/event/quic/ngx_event_quic_connection.h
index 2b198ac6..9b271e07 100644
--- a/src/event/quic/ngx_event_quic_connection.h
+++ b/src/event/quic/ngx_event_quic_connection.h
@@ -37,6 +37,10 @@ typedef struct ngx_quic_keys_s        ngx_quic_keys_t;
 #include <ngx_event_quic_output.h>
 #include <ngx_event_quic_socket.h>
 
+#define NGX_QUIC_DEBUG_PACKETS
+#define NGX_QUIC_DEBUG_FRAMES
+#define NGX_QUIC_DEBUG_ALLOC
+#define NGX_QUIC_DEBUG_CRYPTO
 
 /* RFC 9002, 6.2.2.  Handshakes and New Paths: kInitialRtt */
 #define NGX_QUIC_INITIAL_RTT                 333 /* ms */
@@ -259,6 +263,71 @@ struct ngx_quic_connection_s {
     unsigned                          client_tp_done:1;
 };
 
+#include <intel-ipsec-mb.h>
+
+#ifdef OPENSSL_IS_BORINGSSL
+#define ngx_quic_cipher_t             EVP_AEAD
+#else
+#define ngx_quic_cipher_t             EVP_CIPHER
+#endif
+
+
+typedef struct {
+    const ngx_quic_cipher_t  *c;
+    const EVP_CIPHER         *hp;
+    const EVP_MD             *d;
+} ngx_quic_ciphers_t;
+
+
+typedef struct ngx_quic_secret_s {
+    ngx_str_t                 secret;
+    ngx_str_t                 key;
+    ngx_str_t                 iv;
+    ngx_str_t                 hp;
+} ngx_quic_secret_t;
+
+
+struct ngx_quic_ipsecimb_buf_s {
+    #define IPSECIMB_BATCH_LEN      128
+    #define NGX_QUIC_HP_LEN 5
+
+    ngx_quic_secret_t   *secret;
+    ngx_quic_ciphers_t   ciphers;
+
+    uint8_t k_array[32];
+    uint64_t k_len ;
+    uint8_t *ct_array[IPSECIMB_BATCH_LEN];
+    uint64_t ct_len_array[IPSECIMB_BATCH_LEN];
+    uint8_t *tag_array[IPSECIMB_BATCH_LEN];
+    uint64_t t_len ;
+    uint8_t *aad_array[IPSECIMB_BATCH_LEN];
+    uint64_t a_len;
+    uint8_t *src_array[IPSECIMB_BATCH_LEN];
+    uint8_t *iv[IPSECIMB_BATCH_LEN];
+    uint64_t iv_len ;
+
+    // quic header & pnp are involved by tls_hp
+    uint8_t *quic_sample[IPSECIMB_BATCH_LEN];
+    // uint8_t *quic_ad[IPSECIMB_BATCH_LEN];
+    uint8_t *quic_pnp[IPSECIMB_BATCH_LEN];
+    uint32_t quic_pnp_offset[IPSECIMB_BATCH_LEN];
+
+    uint8_t quic_flags[IPSECIMB_BATCH_LEN];
+    uint8_t quic_pkt_num_len[IPSECIMB_BATCH_LEN];
+    uint8_t quic_mask[NGX_QUIC_HP_LEN];
+
+    // uint8_t rd_idx;
+    uint8_t wr_idx;
+    uint8_t init_flag;
+
+    //payload_offset
+    uint64_t src_offet; //cache buffer
+
+    struct gcm_key_data gdata_key;
+    IMB_MGR *p_mgr ;
+};
+
+typedef struct ngx_quic_ipsecimb_buf_s  ngx_quic_ipsecimb_buf_t;
 
 ngx_int_t ngx_quic_apply_transport_params(ngx_connection_t *c,
     ngx_quic_tp_t *ctp);
diff --git a/src/event/quic/ngx_event_quic_output.c b/src/event/quic/ngx_event_quic_output.c
index b72d3319..1653a4f5 100644
--- a/src/event/quic/ngx_event_quic_output.c
+++ b/src/event/quic/ngx_event_quic_output.c
@@ -119,6 +119,108 @@ ngx_quic_output(ngx_connection_t *c)
     return NGX_OK;
 }
 
+ngx_quic_ipsecimb_buf_t ipsecimb_buf={0};
+ngx_quic_ipsecimb_buf_t* p_qpackets = &ipsecimb_buf;
+
+ngx_int_t
+ngx_quic_tls_hp(ngx_log_t *log, const EVP_CIPHER *cipher,
+    ngx_quic_secret_t *s, u_char *out, u_char *in);
+
+ngx_int_t
+ngx_quic_batch_encrypt_hp(ngx_log_t *log)
+{
+
+    uint64_t num_packets = p_qpackets->wr_idx;
+
+    if(!p_qpackets->wr_idx){
+        return NGX_OK;
+    }
+
+    ngx_log_error(NGX_LOG_NOTICE,log,0,"Metric:batch_gcm_cnt %d",num_packets);
+
+    struct gcm_key_data gdata_key;
+    IMB_AES128_GCM_PRE(p_qpackets->p_mgr, p_qpackets->k_array, &gdata_key);
+
+    imb_quic_aes_gcm(p_qpackets->p_mgr, 
+            &gdata_key, p_qpackets->k_len, 
+            IMB_DIR_ENCRYPT,
+            (void **)p_qpackets->ct_array, 
+            (const void * const*)p_qpackets->src_array, p_qpackets->ct_len_array,
+            (const void * const*)p_qpackets->iv, 
+            (const void * const*)p_qpackets->aad_array, p_qpackets->a_len,
+            ( void **)p_qpackets->tag_array, p_qpackets->t_len,
+            num_packets);
+
+    #define MAX_K   (64)
+
+    void *b_out[MAX_K];
+    const void *b_in[MAX_K];
+    int K = MAX_K;
+    u_char out_buffer[MAX_K][32];
+
+    DECLARE_ALIGNED(uint32_t enc_keys[15*4], 16);
+    DECLARE_ALIGNED(uint32_t dec_keys[15*4], 16);
+    
+    ngx_str_t plain_out[MAX_K];
+
+    u_char e_idx;
+    u_char pkt_num_len;
+
+    for(e_idx =0;e_idx<p_qpackets->wr_idx;e_idx++){
+        /**
+         * set out&in
+        */
+        plain_out[e_idx].data = p_qpackets->ct_array[e_idx];
+        plain_out[e_idx].len  = p_qpackets->ct_len_array[e_idx];
+        b_out[e_idx] = out_buffer[e_idx];
+
+        pkt_num_len = p_qpackets->quic_pkt_num_len[e_idx];
+        b_in[e_idx] = &plain_out[e_idx].data[4-pkt_num_len]; 
+    }
+
+    ngx_quic_secret_t   *s_kp;
+    s_kp = p_qpackets->secret;
+    K = p_qpackets->wr_idx;
+
+    IMB_AES_KEYEXP_128(p_qpackets->p_mgr, s_kp->hp.data, enc_keys, dec_keys);
+    imb_quic_hp_aes_ecb(p_qpackets->p_mgr, enc_keys,
+                                    (void **)b_out, (const void * const *) b_in,
+                                    K, IMB_KEY_128_BYTES);
+
+    /*
+    * Obtain mask
+    * manipulate the PNP & package flag in the QUIC package,
+    *           then generate the'ad' field of GCM's result.
+    *           add mask for the output and xor for the result with flags.
+    */
+    ngx_uint_t  b_i;
+    ngx_str_t b_ad;
+    u_char *b_mask;
+    u_char  *b_pnp;
+    u_char b_flags;
+
+    b_ad.len = p_qpackets->a_len;
+    
+    for(e_idx =0;e_idx<p_qpackets->wr_idx;e_idx++){
+        b_flags = p_qpackets->quic_flags[e_idx];
+        b_ad.data = p_qpackets->aad_array[e_idx];
+        b_mask = b_out[e_idx];
+             
+        b_ad.data[0] ^= b_mask[0] & ngx_quic_pkt_hp_mask(b_flags);
+        
+        b_pnp = p_qpackets->quic_pnp[e_idx];
+        pkt_num_len= p_qpackets->quic_pkt_num_len[e_idx] ;
+
+        for (b_i = 0; b_i < pkt_num_len; b_i++) {
+            b_pnp[b_i] ^= b_mask[b_i + 1];
+        }
+    }
+  
+    p_qpackets->src_offet = 0;
+    p_qpackets->wr_idx = 0;
+
+    return NGX_OK;
+}
 
 static ngx_int_t
 ngx_quic_create_datagrams(ngx_connection_t *c)
@@ -138,9 +240,15 @@ ngx_quic_create_datagrams(ngx_connection_t *c)
     cg = &qc->congestion;
     path = qc->path;
 
+    ngx_log_debug3(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                    "ngx_quic_create_datagrams fd:%d,qc->:%s:%d",
+                    c->fd,
+                    inet_ntoa(((struct sockaddr_in*)c->sockaddr)->sin_addr),
+                    ntohs(((struct sockaddr_in*)c->sockaddr)->sin_port));
+
     while (cg->in_flight < cg->window) {
 
-        p = dst;
+        p =dst ;
 
         len = ngx_min(qc->ctp.max_udp_payload_size,
                       NGX_QUIC_MAX_UDP_PAYLOAD_SIZE);
@@ -177,7 +285,6 @@ ngx_quic_create_datagrams(ngx_connection_t *c)
             if (n == NGX_ERROR) {
                 return NGX_ERROR;
             }
-
             p += n;
             len -= n;
         }
@@ -187,6 +294,8 @@ ngx_quic_create_datagrams(ngx_connection_t *c)
             break;
         }
 
+        ngx_quic_batch_encrypt_hp(c->log);
+
         n = ngx_quic_send(c, dst, len, path->sockaddr, path->socklen);
 
         if (n == NGX_ERROR) {
@@ -320,7 +429,6 @@ ngx_quic_allow_segmentation(ngx_connection_t *c)
     return 0;
 }
 
-
 static ngx_int_t
 ngx_quic_create_segments(ngx_connection_t *c)
 {
@@ -339,6 +447,13 @@ ngx_quic_create_segments(ngx_connection_t *c)
     cg = &qc->congestion;
     path = qc->path;
 
+    ngx_log_debug3(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                    "ngx_quic_create_segments fd:%d,qc->:%s:%d",
+                    c->fd,
+                    inet_ntoa(((struct sockaddr_in*)c->sockaddr)->sin_addr),
+                    ntohs(((struct sockaddr_in*)c->sockaddr)->sin_port));
+    
+
     ctx = ngx_quic_get_send_ctx(qc, ssl_encryption_application);
 
     if (ngx_quic_generate_ack(c, ctx) != NGX_OK) {
@@ -379,6 +494,9 @@ ngx_quic_create_segments(ngx_connection_t *c)
         }
 
         if (n == 0 || nseg == NGX_QUIC_MAX_SEGMENTS) {
+
+            ngx_quic_batch_encrypt_hp(c->log);
+
             n = ngx_quic_send_segments(c, dst, p - dst, path->sockaddr,
                                        path->socklen, segsize);
             if (n == NGX_ERROR) {
@@ -464,6 +582,12 @@ ngx_quic_send_segments(ngx_connection_t *c, u_char *buf, size_t len,
         return n;
     }
 
+    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                           "sendmsg() send out:%d",n);
+
+    ngx_log_error(NGX_LOG_DEBUG, c->log, 0,  "sendmsg() send out:%d",n);
+
+
     c->sent += n;
 
     return n;
@@ -532,17 +656,13 @@ ngx_quic_output_packet(ngx_connection_t *c, ngx_quic_send_ctx_t *ctx,
     ngx_quic_header_t       pkt;
     ngx_quic_connection_t  *qc;
     static u_char           src[NGX_QUIC_MAX_UDP_PAYLOAD_SIZE];
+    u_char *p_adjst_src      = src + p_qpackets->src_offet ;
 
     if (ngx_queue_empty(&ctx->frames)) {
         return 0;
     }
 
-    ngx_log_debug3(NGX_LOG_DEBUG_EVENT, c->log, 0,
-                   "quic output %s packet max:%uz min:%uz",
-                   ngx_quic_level_name(ctx->level), max, min);
-
     qc = ngx_quic_get_connection(c);
-
     ngx_quic_init_packet(c, ctx, &pkt, qc->path);
 
     min_payload = ngx_quic_payload_size(&pkt, min);
@@ -558,7 +678,15 @@ ngx_quic_output_packet(ngx_connection_t *c, ngx_quic_send_ctx_t *ctx,
 
     now = ngx_current_msec;
     nframes = 0;
+#if 0
     p = src;
+#endif
+
+    /*  For the batch mode, each quic frame should reuse the buffer,if not adjust the offset,
+     *  here will be an overlap issue. 
+     */
+
+    p = p_adjst_src;
     len = 0;
     expand = 0;
 
@@ -615,7 +743,10 @@ ngx_quic_output_packet(ngx_connection_t *c, ngx_quic_send_ctx_t *ctx,
             pkt.need_ack = 1;
         }
 
+#if 0
         ngx_quic_log_frame(c->log, f, 1);
+#endif
+
 
         flen = ngx_quic_create_frame(p, f);
         if (flen == -1) {
@@ -646,9 +777,13 @@ ngx_quic_output_packet(ngx_connection_t *c, ngx_quic_send_ctx_t *ctx,
         len = min_payload;
      }
 
+
+#if 0
     pkt.payload.data = src;
+#endif
+// since the payload recorder may cache payloads, adjust the start address.
+    pkt.payload.data = p_adjst_src;
     pkt.payload.len = len;
-
     res.data = data;
 
     ngx_log_debug6(NGX_LOG_DEBUG_EVENT, c->log, 0,
@@ -657,10 +792,14 @@ ngx_quic_output_packet(ngx_connection_t *c, ngx_quic_send_ctx_t *ctx,
                    ngx_quic_level_name(ctx->level), pkt.payload.len,
                    pkt.need_ack, pkt.number, pkt.num_len, pkt.trunc);
 
+
+    p_qpackets->src_offet += len;
+
     if (ngx_quic_encrypt(&pkt, &res) != NGX_OK) {
         return NGX_ERROR;
     }
 
+    
     ctx->pnum++;
 
     if (pkt.need_ack) {
diff --git a/src/event/quic/ngx_event_quic_protection.c b/src/event/quic/ngx_event_quic_protection.c
index bbf85af9..04847126 100644
--- a/src/event/quic/ngx_event_quic_protection.c
+++ b/src/event/quic/ngx_event_quic_protection.c
@@ -28,22 +28,7 @@
 #define ngx_quic_cipher_t             EVP_CIPHER
 #endif
 
-
-typedef struct {
-    const ngx_quic_cipher_t  *c;
-    const EVP_CIPHER         *hp;
-    const EVP_MD             *d;
-} ngx_quic_ciphers_t;
-
-
-typedef struct ngx_quic_secret_s {
-    ngx_str_t                 secret;
-    ngx_str_t                 key;
-    ngx_str_t                 iv;
-    ngx_str_t                 hp;
-} ngx_quic_secret_t;
-
-
+#define BATCH_EH_AND_HP (1)
 typedef struct {
     ngx_quic_secret_t         client;
     ngx_quic_secret_t         server;
@@ -76,7 +61,7 @@ static ngx_int_t ngx_quic_tls_open(const ngx_quic_cipher_t *cipher,
 static ngx_int_t ngx_quic_tls_seal(const ngx_quic_cipher_t *cipher,
     ngx_quic_secret_t *s, ngx_str_t *out, u_char *nonce, ngx_str_t *in,
     ngx_str_t *ad, ngx_log_t *log);
-static ngx_int_t ngx_quic_tls_hp(ngx_log_t *log, const EVP_CIPHER *cipher,
+ngx_int_t ngx_quic_tls_hp(ngx_log_t *log, const EVP_CIPHER *cipher,
     ngx_quic_secret_t *s, u_char *out, u_char *in);
 static ngx_int_t ngx_quic_hkdf_expand(ngx_pool_t *pool, const EVP_MD *digest,
     ngx_str_t *out, ngx_str_t *label, const uint8_t *prk, size_t prk_len);
@@ -498,6 +483,7 @@ ngx_quic_tls_open(const ngx_quic_cipher_t *cipher, ngx_quic_secret_t *s,
     return NGX_OK;
 }
 
+EVP_AEAD_CTX  *ctx = NULL;
 
 static ngx_int_t
 ngx_quic_tls_seal(const ngx_quic_cipher_t *cipher, ngx_quic_secret_t *s,
@@ -505,7 +491,6 @@ ngx_quic_tls_seal(const ngx_quic_cipher_t *cipher, ngx_quic_secret_t *s,
 {
 
 #ifdef OPENSSL_IS_BORINGSSL
-    EVP_AEAD_CTX  *ctx;
 
     ctx = EVP_AEAD_CTX_new(cipher, s->key.data, s->key.len,
                            EVP_AEAD_DEFAULT_TAG_LENGTH);
@@ -524,6 +509,7 @@ ngx_quic_tls_seal(const ngx_quic_cipher_t *cipher, ngx_quic_secret_t *s,
     }
 
     EVP_AEAD_CTX_free(ctx);
+
 #else
     int              len;
     EVP_CIPHER_CTX  *ctx;
@@ -595,7 +581,7 @@ ngx_quic_tls_seal(const ngx_quic_cipher_t *cipher, ngx_quic_secret_t *s,
 }
 
 
-static ngx_int_t
+ngx_int_t
 ngx_quic_tls_hp(ngx_log_t *log, const EVP_CIPHER *cipher,
     ngx_quic_secret_t *s, u_char *out, u_char *in)
 {
@@ -820,15 +806,64 @@ ngx_quic_keys_update(ngx_connection_t *c, ngx_quic_keys_t *keys)
 }
 
 
+extern ngx_quic_ipsecimb_buf_t* p_qpackets;
+extern ngx_int_t ngx_quic_batch_encrypt_hp(ngx_log_t *log);
+
+static ngx_int_t
+ngx_quic_tls_data_recorder(const ngx_quic_cipher_t *cipher, ngx_quic_secret_t *s,
+    ngx_str_t *out, u_char *nonce, ngx_str_t *in, ngx_str_t *ad, ngx_log_t *log)
+{
+    uint64_t wr_idx = p_qpackets->wr_idx;
+
+    /* Initializing on fly */
+    if(!p_qpackets->init_flag){
+        IMB_ARCH arch;
+        p_qpackets->p_mgr = alloc_mb_mgr(IMB_ARCH_AVX512);
+
+        if(p_qpackets->p_mgr == NULL){
+            ngx_log_debug1(NGX_LOG_DEBUG_EVENT, log, 0,
+                "null pointer, should check gcm_mgr:0x%x",p_qpackets->p_mgr);
+        }
+
+        init_mb_mgr_auto(p_qpackets->p_mgr, &arch);
+        p_qpackets->init_flag = 1;
+
+        int i;
+        for(i=0;i<IPSECIMB_BATCH_LEN;i++){
+            p_qpackets->iv[i] = malloc(s->iv.len);
+        }
+        
+    }
+
+    p_qpackets->k_len = s->key.len; 
+    ngx_memcpy(p_qpackets->k_array,s->key.data,s->key.len);
+
+    p_qpackets->src_array[wr_idx] = in->data;
+    p_qpackets->ct_len_array[wr_idx] = in->len;
+
+    p_qpackets->aad_array[wr_idx] = ad->data;
+    p_qpackets->a_len = ad->len;
+    
+    ngx_memcpy(p_qpackets->iv[wr_idx],nonce,s->iv.len);
+    p_qpackets->iv_len     = s->iv.len;
+
+    p_qpackets->ct_array[wr_idx] = out->data;
+
+    p_qpackets->t_len = s->key.len;
+    p_qpackets->tag_array[wr_idx] = out->data+out->len -  p_qpackets->t_len ;
+
+    return NGX_OK;
+}
+
+
 static ngx_int_t
 ngx_quic_create_packet(ngx_quic_header_t *pkt, ngx_str_t *res)
 {
-    u_char              *pnp, *sample;
+    u_char              *pnp;
     ngx_str_t            ad, out;
-    ngx_uint_t           i;
     ngx_quic_secret_t   *secret;
     ngx_quic_ciphers_t   ciphers;
-    u_char               nonce[NGX_QUIC_IV_LEN], mask[NGX_QUIC_HP_LEN];
+    u_char               nonce[NGX_QUIC_IV_LEN];
 
     ad.data = res->data;
     ad.len = ngx_quic_create_header(pkt, ad.data, &pnp);
@@ -851,6 +886,11 @@ ngx_quic_create_packet(ngx_quic_header_t *pkt, ngx_str_t *res)
     ngx_memcpy(nonce, secret->iv.data, secret->iv.len);
     ngx_quic_compute_nonce(nonce, sizeof(nonce), pkt->number);
 
+    u_char w_idx ;
+
+#if BATCH_EH_AND_HP == 0
+    /* replaced by batch_encrypt interface */
+
     if (ngx_quic_tls_seal(ciphers.c, secret, &out,
                           nonce, &pkt->payload, &ad, pkt->log)
         != NGX_OK)
@@ -858,26 +898,44 @@ ngx_quic_create_packet(ngx_quic_header_t *pkt, ngx_str_t *res)
         return NGX_ERROR;
     }
 
-    sample = &out.data[4 - pkt->num_len];
-    if (ngx_quic_tls_hp(pkt->log, ciphers.hp, secret, mask, sample)
+#endif
+
+#if BATCH_EH_AND_HP
+     /* For the case: when the encyrption keys are changed, 
+     *                 the buffer plain text must swap out immediately.
+     */
+     if(p_qpackets->k_len ){
+        if(ngx_memcmp(p_qpackets->k_array,secret->key.data,secret->key.len)){
+             ngx_quic_batch_encrypt_hp(pkt->log);
+        }
+     }
+   
+
+    /* Gether a batch plain text as array, then hand off to ngx_quic_encrypt_batch for encryption. */
+    if (ngx_quic_tls_data_recorder(ciphers.c, secret, &out,
+                          nonce, &pkt->payload, &ad, pkt->log)
         != NGX_OK)
     {
         return NGX_ERROR;
     }
+    
+    p_qpackets->secret = secret;
+    p_qpackets->ciphers = ciphers;
 
-    /* RFC 9001, 5.4.1.  Header Protection Application */
-    ad.data[0] ^= mask[0] & ngx_quic_pkt_hp_mask(pkt->flags);
+    w_idx = p_qpackets->wr_idx;
 
-    for (i = 0; i < pkt->num_len; i++) {
-        pnp[i] ^= mask[i + 1];
-    }
+    p_qpackets->quic_pkt_num_len[w_idx] = pkt->num_len;
+    p_qpackets->quic_flags[w_idx] = pkt->flags;
+    p_qpackets->quic_sample[w_idx] = &out.data[4-pkt->num_len];
+    p_qpackets->quic_pnp[w_idx] = pnp;
 
+    p_qpackets->wr_idx++;
     res->len = ad.len + out.len;
+#endif
 
     return NGX_OK;
 }
 
-
 static ngx_int_t
 ngx_quic_create_retry_packet(ngx_quic_header_t *pkt, ngx_str_t *res)
 {
@@ -1037,7 +1095,6 @@ ngx_quic_encrypt(ngx_quic_header_t *pkt, ngx_str_t *res)
     return ngx_quic_create_packet(pkt, res);
 }
 
-
 ngx_int_t
 ngx_quic_decrypt(ngx_quic_header_t *pkt, uint64_t *largest_pn)
 {
