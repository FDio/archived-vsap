From dea792cdf1af0b343180846c33be14681323f5a3 Mon Sep 17 00:00:00 2001
From: Yu Ping <ping.yu@intel.com>
Date: Wed, 23 Oct 2019 17:56:55 +0800
Subject: [PATCH] LDP remove lock

Change-Id: I3b5135194ed93c5e4a259fb2d3f8cae7ef8de4c5
Signed-off-by: Yu Ping <ping.yu@intel.com>
---
 src/vcl/CMakeLists.txt |   5 +-
 src/vcl/ldp.c          | 740 +++++++++++++++++++++++++++--------------
 src/vcl/ldp.h          |   2 +-
 src/vcl/vcl_private.h  |   7 +-
 4 files changed, 495 insertions(+), 259 deletions(-)

diff --git a/src/vcl/CMakeLists.txt b/src/vcl/CMakeLists.txt
index ab0a6ad6a..0d30eb6af 100644
--- a/src/vcl/CMakeLists.txt
+++ b/src/vcl/CMakeLists.txt
@@ -20,7 +20,6 @@ add_vpp_library(vppcom
   vcl_bapi.c
   vcl_cfg.c
   vcl_private.c
-  vcl_locked.c
 
   LINK_LIBRARIES
   vppinfra svm vlibmemoryclient rt pthread
@@ -41,7 +40,7 @@ add_vpp_library(vcl_ldpreload
 add_vpp_headers(vcl
   ldp.h
   ldp_glibc_socket.h
+  vcl_private.h
   vppcom.h
-  vcl_locked.h
   ldp_socket_wrapper.h
-)
\ No newline at end of file
+)
diff --git a/src/vcl/ldp.c b/src/vcl/ldp.c
index 7aa383052..4e7695454 100644
--- a/src/vcl/ldp.c
+++ b/src/vcl/ldp.c
@@ -24,9 +24,10 @@
 
 #include <vcl/ldp_socket_wrapper.h>
 #include <vcl/ldp.h>
+#include <vcl/vppcom.h>
+#include <vcl/vcl_private.h>
 #include <sys/time.h>
 
-#include <vcl/vcl_locked.h>
 #include <vppinfra/time.h>
 #include <vppinfra/bitmap.h>
 #include <vppinfra/lock.h>
@@ -96,8 +97,8 @@ typedef struct
   ldp_worker_ctx_t *workers;
   int init;
   char app_name[LDP_APP_NAME_MAX];
-  u32 vlsh_bit_val;
-  u32 vlsh_bit_mask;
+  u32 vcl_bit_val;
+  u32 vcl_bit_mask;
   u32 debug;
   u8 transparent_tls;
 
@@ -112,8 +113,8 @@ typedef struct
     clib_warning ("ldp<%d>: " _fmt, getpid(), ##_args)
 
 static ldp_main_t ldp_main = {
-  .vlsh_bit_val = (1 << LDP_SID_BIT_MIN),
-  .vlsh_bit_mask = (1 << LDP_SID_BIT_MIN) - 1,
+  .vcl_bit_val = (1 << LDP_SID_BIT_MIN),
+  .vcl_bit_mask = (1 << LDP_SID_BIT_MIN) - 1,
   .debug = LDP_DEBUG_INIT,
   .transparent_tls = 0,
 };
@@ -146,18 +147,18 @@ ldp_get_app_name ()
 }
 
 static inline int
-ldp_vlsh_to_fd (vls_handle_t vlsh)
+ldp_vclsh_to_fd (vcl_session_handle_t vclsh)
 {
-  return (vlsh + ldp->vlsh_bit_val);
+  return (vclsh + ldp->vcl_bit_val);
 }
 
-static inline vls_handle_t
-ldp_fd_to_vlsh (int fd)
+static inline vcl_session_handle_t
+ldp_fd_to_vclsh (int fd)
 {
-  if (fd < ldp->vlsh_bit_val)
-    return VLS_INVALID_HANDLE;
+  if (fd < (ldp->vcl_bit_val))
+    return INVALID_SESSION_ID;
 
-  return (fd - ldp->vlsh_bit_val);
+  return (fd - ldp->vcl_bit_val);
 }
 
 static void
@@ -168,6 +169,194 @@ ldp_alloc_workers (void)
   pool_alloc (ldp->workers, LDP_MAX_NWORKERS);
 }
 
+static void
+ldp_share_listen_session (vcl_worker_t * parent_wrk,
+			  vcl_worker_t * child_wrk,
+			  vcl_session_t * listen_session)
+{
+/*Find the listen session of parent worker*/
+  if (listen_session->session_index == parent_wrk->listen_session_index)
+    {
+      listen_session->session_state = STATE_LISTEN_NO_MQ;
+      vppcom_session_listen (vcl_session_handle_from_index
+			     (parent_wrk->listen_session_index),
+			     parent_wrk->listen_queue_size);
+    }
+}
+
+void
+ldp_vcl_worker_copy_on_fork (vcl_worker_t * parent_wrk)
+{
+  vcl_worker_t *wrk = vcl_worker_get_current ();
+  vcl_session_t *listen_session;
+  wrk->vpp_event_queues = vec_dup (parent_wrk->vpp_event_queues);
+  wrk->sessions = pool_dup (parent_wrk->sessions);
+  wrk->session_index_by_vpp_handles =
+    hash_dup (parent_wrk->session_index_by_vpp_handles);
+/*Update listen session for child*/
+  pool_foreach (listen_session, wrk->sessions, (
+						 {
+						 ldp_share_listen_session
+						 (parent_wrk, wrk,
+						  listen_session);}));
+}
+
+static void
+ldp_cleanup_vcl_worker (vcl_worker_t * wrk)
+{
+  vcl_worker_cleanup (wrk, 1 /* notify vpp */ );
+}
+
+static void
+ldp_cleanup_forked_child (vcl_worker_t * wrk, vcl_worker_t * child_wrk)
+{
+  vcl_worker_t *sub_child;
+  int tries = 0;
+
+  if (child_wrk->forked_child != ~0)
+    {
+      sub_child = vcl_worker_get_if_valid (child_wrk->forked_child);
+      if (sub_child)
+	{
+	  /* Wait a bit, maybe the process is going away */
+	  while (kill (sub_child->current_pid, 0) >= 0 && tries++ < 50)
+	    usleep (1e3);
+	  if (kill (sub_child->current_pid, 0) < 0)
+	    ldp_cleanup_forked_child (child_wrk, sub_child);
+	}
+    }
+  ldp_cleanup_vcl_worker (child_wrk);
+  VDBG (0, "Cleaned up forked child wrk %u", child_wrk->wrk_index);
+  wrk->forked_child = ~0;
+}
+
+static struct sigaction old_sa;
+
+static void
+ldp_intercept_sigchld_handler (int signum, siginfo_t * si, void *uc)
+{
+  vcl_worker_t *wrk, *child_wrk;
+
+  if (vcl_get_worker_index () == ~0)
+    return;
+
+  /*restore sigchld */
+  if (sigaction (SIGCHLD, &old_sa, 0))
+    {
+      VERR ("couldn't restore sigchld");
+      exit (-1);
+    }
+
+  wrk = vcl_worker_get_current ();
+  if (wrk->forked_child == ~0)
+    return;
+
+  child_wrk = vcl_worker_get_if_valid (wrk->forked_child);
+  if (!child_wrk)
+    goto done;
+
+  if (si && si->si_pid != child_wrk->current_pid)
+    {
+      VDBG (0, "unexpected child pid %u", si->si_pid);
+      goto done;
+    }
+  ldp_cleanup_forked_child (wrk, child_wrk);
+
+done:
+  if (old_sa.sa_flags & SA_SIGINFO)
+    {
+      void (*fn) (int, siginfo_t *, void *) = old_sa.sa_sigaction;
+      fn (signum, si, uc);
+    }
+  else
+    {
+      void (*fn) (int) = old_sa.sa_handler;
+      if (fn)
+	fn (signum);
+    }
+}
+
+/*Intercept signal SIGCHLD*/
+static void
+ldp_intercept_sigchld ()
+{
+  struct sigaction sa;
+  clib_memset (&sa, 0, sizeof (sa));
+  /*set SA_SIGINFO to validate sa.sa_sigaction rather than sa.sa_handler */
+  sa.sa_sigaction = ldp_intercept_sigchld_handler;
+  sa.sa_flags = SA_SIGINFO;
+  /*When current process receive the SIGCHLD signal, it would call
+   **ldp_intercept_sigchld_handler.
+   */
+  if (sigaction (SIGCHLD, &sa, &old_sa))
+    {
+      VERR ("couldn't intercept sigchld");
+      exit (-1);
+    }
+}
+
+static void
+ldp_app_pre_fork (void)
+{
+  ldp_intercept_sigchld ();
+  vcl_flush_mq_events ();
+}
+
+static void
+ldp_app_fork_parent_handler (void)
+{
+  vcl_session_t *listen_session;
+  vcl_worker_t *wrk = vcl_worker_get_current ();
+  listen_session = vcl_session_get (wrk, wrk->listen_session_index);
+  listen_session->session_state = STATE_LISTEN_NO_MQ;
+  vcl_send_session_unlisten (wrk, listen_session);
+  vcm->forking = 1;
+  while (vcm->forking)
+    ;
+
+}
+
+static void
+ldp_app_fork_child_handler (void)
+{
+  vcl_worker_t *parent_wrk;
+  int rv, parent_wrk_index;
+  u8 *child_name;
+
+  parent_wrk_index = vcl_get_worker_index ();
+  VDBG (0,
+	"initializing forked child (pid) %u with parent wrk (vcl worker index) %u",
+	getpid (), parent_wrk_index);
+
+/*Allocate vcl worker for child*/
+  vcl_set_worker_index (~0);
+  if (!vcl_worker_alloc_and_init ())
+    VERR ("couldn't allocate new worker for child process %u", getpid ());
+
+/*Attach to binary api*/
+  child_name = format (0, "%v-child-%u%c", vcm->app_name, getpid (), 0);
+  vcl_cleanup_bapi ();
+  vppcom_api_hookup ();
+  vcm->app_state = STATE_APP_START;
+  rv = vppcom_connect_to_vpp ((char *) child_name);
+  vec_free (child_name);
+  if (rv)
+    {
+      VERR ("couldn't connect to VPP!");
+      return;
+    }
+
+/*
+**Register new allocated vcl worker with VPP
+*/
+  vcl_worker_register_with_vpp ();
+  parent_wrk = vcl_worker_get (parent_wrk_index);
+  ldp_vcl_worker_copy_on_fork (parent_wrk);
+  parent_wrk->forked_child = vcl_get_worker_index ();
+  VDBG (0, "forked child main worker initialized");
+  vcm->forking = 0;
+}
+
 static inline int
 ldp_init (void)
 {
@@ -179,7 +368,9 @@ ldp_init (void)
 
   ldp->init = 1;
   ldp->vcl_needs_real_epoll = 1;
-  rv = vls_app_create (ldp_get_app_name ());
+  rv = vppcom_app_create (ldp_get_app_name ());
+  pthread_atfork (ldp_app_pre_fork, ldp_app_fork_parent_handler,
+		  ldp_app_fork_child_handler);
   if (rv != VPPCOM_OK)
     {
       ldp->vcl_needs_real_epoll = 0;
@@ -226,43 +417,43 @@ ldp_init (void)
 	{
 	  LDBG (0, "WARNING: Invalid LDP sid bit specified in the env var "
 		LDP_ENV_SID_BIT " (%s)! sid bit value %d (0x%x)", env_var_str,
-		ldp->vlsh_bit_val, ldp->vlsh_bit_val);
+		ldp->vcl_bit_val, ldp->vcl_bit_val);
 	}
       else if (sb < LDP_SID_BIT_MIN)
 	{
-	  ldp->vlsh_bit_val = (1 << LDP_SID_BIT_MIN);
-	  ldp->vlsh_bit_mask = ldp->vlsh_bit_val - 1;
+	  ldp->vcl_bit_val = (1 << LDP_SID_BIT_MIN);
+	  ldp->vcl_bit_mask = ldp->vcl_bit_val - 1;
 
 	  LDBG (0, "WARNING: LDP sid bit (%u) specified in the env var "
 		LDP_ENV_SID_BIT " (%s) is too small. Using LDP_SID_BIT_MIN"
 		" (%d)! sid bit value %d (0x%x)", sb, env_var_str,
-		LDP_SID_BIT_MIN, ldp->vlsh_bit_val, ldp->vlsh_bit_val);
+		LDP_SID_BIT_MIN, ldp->vcl_bit_val, ldp->vcl_bit_val);
 	}
       else if (sb > LDP_SID_BIT_MAX)
 	{
-	  ldp->vlsh_bit_val = (1 << LDP_SID_BIT_MAX);
-	  ldp->vlsh_bit_mask = ldp->vlsh_bit_val - 1;
+	  ldp->vcl_bit_val = (1 << LDP_SID_BIT_MAX);
+	  ldp->vcl_bit_mask = ldp->vcl_bit_val - 1;
 
 	  LDBG (0, "WARNING: LDP sid bit (%u) specified in the env var "
 		LDP_ENV_SID_BIT " (%s) is too big. Using LDP_SID_BIT_MAX"
 		" (%d)! sid bit value %d (0x%x)", sb, env_var_str,
-		LDP_SID_BIT_MAX, ldp->vlsh_bit_val, ldp->vlsh_bit_val);
+		LDP_SID_BIT_MAX, ldp->vcl_bit_val, ldp->vcl_bit_val);
 	}
       else
 	{
-	  ldp->vlsh_bit_val = (1 << sb);
-	  ldp->vlsh_bit_mask = ldp->vlsh_bit_val - 1;
+	  ldp->vcl_bit_val = (1 << sb);
+	  ldp->vcl_bit_mask = ldp->vcl_bit_val - 1;
 
 	  LDBG (0, "configured LDP sid bit (%u) from "
 		LDP_ENV_SID_BIT "!  sid bit value %d (0x%x)", sb,
-		ldp->vlsh_bit_val, ldp->vlsh_bit_val);
+		ldp->vcl_bit_val, ldp->vcl_bit_val);
 	}
 
       /* Make sure there are enough bits in the fd set for vcl sessions */
-      if (ldp->vlsh_bit_val > FD_SETSIZE / 2)
+      if (ldp->vcl_bit_val > FD_SETSIZE / 2)
 	{
-	  LDBG (0, "ERROR: LDP vlsh bit value %d > FD_SETSIZE/2 %d!",
-		ldp->vlsh_bit_val, FD_SETSIZE / 2);
+	  LDBG (0, "ERROR: LDP vclsh bit value %d > FD_SETSIZE/2 %d!",
+		ldp->vcl_bit_val, FD_SETSIZE / 2);
 	  ldp->init = 0;
 	  return -1;
 	}
@@ -287,16 +478,16 @@ ldp_init (void)
 int
 close (int fd)
 {
-  vls_handle_t vlsh;
+  vcl_session_handle_t vclsh;
   int rv, epfd;
 
   if ((errno = -ldp_init ()))
     return -1;
 
-  vlsh = ldp_fd_to_vlsh (fd);
-  if (vlsh != VLS_INVALID_HANDLE)
+  vclsh = ldp_fd_to_vclsh (fd);
+  if (vclsh != INVALID_SESSION_ID)
     {
-      epfd = vls_attr (vlsh, VPPCOM_ATTR_GET_LIBC_EPFD, 0, 0);
+      epfd = vppcom_session_attr (vclsh, VPPCOM_ATTR_GET_LIBC_EPFD, 0, 0);
       if (epfd > 0)
 	{
 	  LDBG (0, "fd %d: calling libc_close: epfd %u", fd, epfd);
@@ -307,7 +498,8 @@ close (int fd)
 	      u32 size = sizeof (epfd);
 	      epfd = 0;
 
-	      (void) vls_attr (vlsh, VPPCOM_ATTR_SET_LIBC_EPFD, &epfd, &size);
+	      (void) vppcom_session_attr (vclsh, VPPCOM_ATTR_SET_LIBC_EPFD,
+					  &epfd, &size);
 	    }
 	}
       else if (PREDICT_FALSE (epfd < 0))
@@ -317,9 +509,9 @@ close (int fd)
 	  goto done;
 	}
 
-      LDBG (0, "fd %d: calling vls_close: vlsh %u", fd, vlsh);
+      LDBG (0, "fd %d: calling vppcom_session_close: vclsh %u", fd, vclsh);
 
-      rv = vls_close (vlsh);
+      rv = vppcom_session_close (vclsh);
       if (rv != VPPCOM_OK)
 	{
 	  errno = -rv;
@@ -339,16 +531,16 @@ done:
 ssize_t
 read (int fd, void *buf, size_t nbytes)
 {
-  vls_handle_t vlsh;
+  vcl_session_handle_t vclsh;
   ssize_t size;
 
   if ((errno = -ldp_init ()))
     return -1;
 
-  vlsh = ldp_fd_to_vlsh (fd);
-  if (vlsh != VLS_INVALID_HANDLE)
+  vclsh = ldp_fd_to_vclsh (fd);
+  if (vclsh != INVALID_SESSION_ID)
     {
-      size = vls_read (vlsh, buf, nbytes);
+      size = vppcom_session_read (vclsh, buf, nbytes);
       if (size < 0)
 	{
 	  errno = -size;
@@ -367,20 +559,21 @@ ssize_t
 readv (int fd, const struct iovec * iov, int iovcnt)
 {
   int rv = 0, i, total = 0;
-  vls_handle_t vlsh;
+  vcl_session_handle_t vclsh;
   ssize_t size = 0;
 
   if ((errno = -ldp_init ()))
     return -1;
 
-  vlsh = ldp_fd_to_vlsh (fd);
-  if (vlsh != VLS_INVALID_HANDLE)
+  vclsh = ldp_fd_to_vclsh (fd);
+  if (vclsh != INVALID_SESSION_ID)
     {
       do
 	{
 	  for (i = 0; i < iovcnt; ++i)
 	    {
-	      rv = vls_read (vlsh, iov[i].iov_base, iov[i].iov_len);
+	      rv =
+		vppcom_session_read (vclsh, iov[i].iov_base, iov[i].iov_len);
 	      if (rv < 0)
 		break;
 	      else
@@ -412,16 +605,16 @@ readv (int fd, const struct iovec * iov, int iovcnt)
 ssize_t
 write (int fd, const void *buf, size_t nbytes)
 {
-  vls_handle_t vlsh;
+  vcl_session_handle_t vclsh;
   ssize_t size = 0;
 
   if ((errno = -ldp_init ()))
     return -1;
 
-  vlsh = ldp_fd_to_vlsh (fd);
-  if (vlsh != VLS_INVALID_HANDLE)
+  vclsh = ldp_fd_to_vclsh (fd);
+  if (vclsh != INVALID_SESSION_ID)
     {
-      size = vls_write_msg (vlsh, (void *) buf, nbytes);
+      size = vppcom_session_write_msg (vclsh, (void *) buf, nbytes);
       if (size < 0)
 	{
 	  errno = -size;
@@ -440,20 +633,22 @@ ssize_t
 writev (int fd, const struct iovec * iov, int iovcnt)
 {
   ssize_t size = 0, total = 0;
-  vls_handle_t vlsh;
+  vcl_session_handle_t vclsh;
   int i, rv = 0;
 
   if ((errno = -ldp_init ()))
     return -1;
 
-  vlsh = ldp_fd_to_vlsh (fd);
-  if (vlsh != VLS_INVALID_HANDLE)
+  vclsh = ldp_fd_to_vclsh (fd);
+  if (vclsh != INVALID_SESSION_ID)
     {
       do
 	{
 	  for (i = 0; i < iovcnt; ++i)
 	    {
-	      rv = vls_write_msg (vlsh, iov[i].iov_base, iov[i].iov_len);
+	      rv =
+		vppcom_session_write_msg (vclsh, iov[i].iov_base,
+					  iov[i].iov_len);
 	      if (rv < 0)
 		break;
 	      else
@@ -485,7 +680,7 @@ writev (int fd, const struct iovec * iov, int iovcnt)
 int
 fcntl (int fd, int cmd, ...)
 {
-  vls_handle_t vlsh;
+  vcl_session_handle_t vclsh;
   int rv = 0;
   va_list ap;
 
@@ -494,9 +689,9 @@ fcntl (int fd, int cmd, ...)
 
   va_start (ap, cmd);
 
-  vlsh = ldp_fd_to_vlsh (fd);
-  LDBG (0, "fd %u vlsh %d, cmd %u", fd, vlsh, cmd);
-  if (vlsh != VLS_INVALID_HANDLE)
+  vclsh = ldp_fd_to_vclsh (fd);
+  LDBG (0, "fd %u vclsh %d, cmd %u", fd, vclsh, cmd);
+  if (vclsh != INVALID_SESSION_ID)
     {
       int flags = va_arg (ap, int);
       u32 size;
@@ -506,11 +701,13 @@ fcntl (int fd, int cmd, ...)
       switch (cmd)
 	{
 	case F_SETFL:
-	  rv = vls_attr (vlsh, VPPCOM_ATTR_SET_FLAGS, &flags, &size);
+	  rv =
+	    vppcom_session_attr (vclsh, VPPCOM_ATTR_SET_FLAGS, &flags, &size);
 	  break;
 
 	case F_GETFL:
-	  rv = vls_attr (vlsh, VPPCOM_ATTR_GET_FLAGS, &flags, &size);
+	  rv =
+	    vppcom_session_attr (vclsh, VPPCOM_ATTR_GET_FLAGS, &flags, &size);
 	  if (rv == VPPCOM_OK)
 	    rv = flags;
 	  break;
@@ -542,7 +739,7 @@ fcntl (int fd, int cmd, ...)
 int
 ioctl (int fd, unsigned long int cmd, ...)
 {
-  vls_handle_t vlsh;
+  vcl_session_handle_t vclsh;
   va_list ap;
   int rv;
 
@@ -551,13 +748,13 @@ ioctl (int fd, unsigned long int cmd, ...)
 
   va_start (ap, cmd);
 
-  vlsh = ldp_fd_to_vlsh (fd);
-  if (vlsh != VLS_INVALID_HANDLE)
+  vclsh = ldp_fd_to_vclsh (fd);
+  if (vclsh != INVALID_SESSION_ID)
     {
       switch (cmd)
 	{
 	case FIONREAD:
-	  rv = vls_attr (vlsh, VPPCOM_ATTR_GET_NREAD, 0, 0);
+	  rv = vppcom_session_attr (vclsh, VPPCOM_ATTR_GET_NREAD, 0, 0);
 	  break;
 
 	case FIONBIO:
@@ -569,7 +766,9 @@ ioctl (int fd, unsigned long int cmd, ...)
 	     *      non-blocking, the flags should be read here and merged
 	     *      with O_NONBLOCK.
 	     */
-	    rv = vls_attr (vlsh, VPPCOM_ATTR_SET_FLAGS, &flags, &size);
+	    rv =
+	      vppcom_session_attr (vclsh, VPPCOM_ATTR_SET_FLAGS, &flags,
+				   &size);
 	  }
 	  break;
 
@@ -599,7 +798,7 @@ ldp_select_init_maps (fd_set * __restrict original,
 		      u32 n_bytes, uword * si_bits, uword * libc_bits)
 {
   uword si_bits_set, libc_bits_set;
-  vls_handle_t vlsh;
+  vcl_session_handle_t vclsh;
   int fd;
 
   clib_bitmap_validate (*vclb, minbits);
@@ -612,11 +811,11 @@ ldp_select_init_maps (fd_set * __restrict original,
   clib_bitmap_foreach (fd, *resultb, ({
     if (fd > nfds)
       break;
-    vlsh = ldp_fd_to_vlsh (fd);
-    if (vlsh == VLS_INVALID_HANDLE)
+    vclsh = ldp_fd_to_vclsh (fd);
+    if (vclsh == INVALID_SESSION_ID)
       clib_bitmap_set_no_check (*libcb, fd, 1);
     else
-      clib_bitmap_set_no_check (*vclb, vlsh_to_session_index (vlsh), 1);
+      clib_bitmap_set_no_check (*vclb, vppcom_session_index (vclsh), 1);
   }));
   /* *INDENT-ON* */
 
@@ -630,7 +829,7 @@ ldp_select_init_maps (fd_set * __restrict original,
 always_inline int
 ldp_select_vcl_map_to_libc (clib_bitmap_t * vclb, fd_set * __restrict libcb)
 {
-  vls_handle_t vlsh;
+  vcl_session_handle_t vclsh;
   uword si;
   int fd;
 
@@ -639,8 +838,8 @@ ldp_select_vcl_map_to_libc (clib_bitmap_t * vclb, fd_set * __restrict libcb)
 
   /* *INDENT-OFF* */
   clib_bitmap_foreach (si, vclb, ({
-    vlsh = vls_session_index_to_vlsh (si);
-    fd = ldp_vlsh_to_fd (vlsh);
+    vclsh = vcl_session_handle_from_index (si);
+    fd = ldp_vclsh_to_fd (vclsh);
     if (PREDICT_FALSE (fd < 0))
       {
         errno = EBADFD;
@@ -713,7 +912,7 @@ ldp_pselect (int nfds, fd_set * __restrict readfds,
   else
     time_out = -1;
 
-  if (nfds <= ldp->vlsh_bit_val)
+  if (nfds <= ldp->vcl_bit_val)
     {
       rv = libc_pselect (nfds, readfds, writefds, exceptfds,
 			 timeout, sigmask);
@@ -763,9 +962,10 @@ ldp_pselect (int nfds, fd_set * __restrict readfds,
 			      vec_len (ldpw->ex_bitmap) *
 			      sizeof (clib_bitmap_t));
 
-	  rv = vls_select (si_bits, readfds ? ldpw->rd_bitmap : NULL,
-			   writefds ? ldpw->wr_bitmap : NULL,
-			   exceptfds ? ldpw->ex_bitmap : NULL, vcl_timeout);
+	  rv = vppcom_select (si_bits, readfds ? ldpw->rd_bitmap : NULL,
+			      writefds ? ldpw->wr_bitmap : NULL,
+			      exceptfds ? ldpw->ex_bitmap : NULL,
+			      vcl_timeout);
 	  if (rv < 0)
 	    {
 	      errno = -rv;
@@ -877,7 +1077,7 @@ pselect (int nfds, fd_set * __restrict readfds,
 /* If transparent TLS mode is turned on, then ldp will load key and cert.
  */
 static int
-load_tls_cert (vls_handle_t vlsh)
+load_tls_cert (vcl_session_handle_t vclsh)
 {
   char *env_var_str = getenv (LDP_ENV_TLS_CERT);
   char inbuf[4096];
@@ -895,7 +1095,7 @@ load_tls_cert (vls_handle_t vlsh)
 	}
       cert_size = fread (inbuf, sizeof (char), sizeof (inbuf), fp);
       tls_cert = inbuf;
-      vppcom_session_tls_add_cert (vlsh_to_session_index (vlsh), tls_cert,
+      vppcom_session_tls_add_cert (vppcom_session_index (vclsh), tls_cert,
 				   cert_size);
       fclose (fp);
     }
@@ -909,7 +1109,7 @@ load_tls_cert (vls_handle_t vlsh)
 }
 
 static int
-load_tls_key (vls_handle_t vlsh)
+load_tls_key (vcl_session_handle_t vclsh)
 {
   char *env_var_str = getenv (LDP_ENV_TLS_KEY);
   char inbuf[4096];
@@ -927,7 +1127,7 @@ load_tls_key (vls_handle_t vlsh)
 	}
       key_size = fread (inbuf, sizeof (char), sizeof (inbuf), fp);
       tls_key = inbuf;
-      vppcom_session_tls_add_key (vlsh_to_session_index (vlsh), tls_key,
+      vppcom_session_tls_add_key (vppcom_session_index (vclsh), tls_key,
 				  key_size);
       fclose (fp);
     }
@@ -944,7 +1144,7 @@ socket (int domain, int type, int protocol)
 {
   int rv, sock_type = type & ~(SOCK_CLOEXEC | SOCK_NONBLOCK);
   u8 is_nonblocking = type & SOCK_NONBLOCK ? 1 : 0;
-  vls_handle_t vlsh;
+  vcl_session_handle_t vclsh;
 
   if ((errno = -ldp_init ()))
     return -1;
@@ -961,25 +1161,26 @@ socket (int domain, int type, int protocol)
 	proto = ((sock_type == SOCK_DGRAM) ?
 		 VPPCOM_PROTO_UDP : VPPCOM_PROTO_TCP);
 
-      LDBG (0, "calling vls_create: proto %u (%s), is_nonblocking %u",
+      LDBG (0,
+	    "calling vppcom_session_create: proto %u (%s), is_nonblocking %u",
 	    proto, vppcom_proto_str (proto), is_nonblocking);
 
-      vlsh = vls_create (proto, is_nonblocking);
-      if (vlsh < 0)
+      vclsh = vppcom_session_create (proto, is_nonblocking);
+      if (vclsh < 0)
 	{
-	  errno = -vlsh;
+	  errno = -vclsh;
 	  rv = -1;
 	}
       else
 	{
 	  if (ldp->transparent_tls)
 	    {
-	      if (load_tls_cert (vlsh) < 0 || load_tls_key (vlsh) < 0)
+	      if (load_tls_cert (vclsh) < 0 || load_tls_key (vclsh) < 0)
 		{
 		  return -1;
 		}
 	    }
-	  rv = ldp_vlsh_to_fd (vlsh);
+	  rv = ldp_vclsh_to_fd (vclsh);
 	}
     }
   else
@@ -1025,14 +1226,14 @@ socketpair (int domain, int type, int protocol, int fds[2])
 int
 bind (int fd, __CONST_SOCKADDR_ARG addr, socklen_t len)
 {
-  vls_handle_t vlsh;
+  vcl_session_handle_t vclsh;
   int rv;
 
   if ((errno = -ldp_init ()))
     return -1;
 
-  vlsh = ldp_fd_to_vlsh (fd);
-  if (vlsh != VLS_INVALID_HANDLE)
+  vclsh = ldp_fd_to_vclsh (fd);
+  if (vclsh != INVALID_SESSION_ID)
     {
       vppcom_endpt_t ep;
 
@@ -1041,8 +1242,8 @@ bind (int fd, __CONST_SOCKADDR_ARG addr, socklen_t len)
 	case AF_INET:
 	  if (len != sizeof (struct sockaddr_in))
 	    {
-	      LDBG (0, "ERROR: fd %d: vlsh %u: Invalid AF_INET addr len %u!",
-		    fd, vlsh, len);
+	      LDBG (0, "ERROR: fd %d: vclsh %u: Invalid AF_INET addr len %u!",
+		    fd, vclsh, len);
 	      errno = EINVAL;
 	      rv = -1;
 	      goto done;
@@ -1055,8 +1256,9 @@ bind (int fd, __CONST_SOCKADDR_ARG addr, socklen_t len)
 	case AF_INET6:
 	  if (len != sizeof (struct sockaddr_in6))
 	    {
-	      LDBG (0, "ERROR: fd %d: vlsh %u: Invalid AF_INET6 addr len %u!",
-		    fd, vlsh, len);
+	      LDBG (0,
+		    "ERROR: fd %d: vclsh %u: Invalid AF_INET6 addr len %u!",
+		    fd, vclsh, len);
 	      errno = EINVAL;
 	      rv = -1;
 	      goto done;
@@ -1067,16 +1269,17 @@ bind (int fd, __CONST_SOCKADDR_ARG addr, socklen_t len)
 	  break;
 
 	default:
-	  LDBG (0, "ERROR: fd %d: vlsh %u: Unsupported address family %u!",
-		fd, vlsh, addr->sa_family);
+	  LDBG (0, "ERROR: fd %d: vclsh %u: Unsupported address family %u!",
+		fd, vclsh, addr->sa_family);
 	  errno = EAFNOSUPPORT;
 	  rv = -1;
 	  goto done;
 	}
-      LDBG (0, "fd %d: calling vls_bind: vlsh %u, addr %p, len %u", fd, vlsh,
-	    addr, len);
+      LDBG (0,
+	    "fd %d: calling vppcom_session_bind: vclsh %u, addr %p, len %u",
+	    fd, vclsh, addr, len);
 
-      rv = vls_bind (vlsh, &ep);
+      rv = vppcom_session_bind (vclsh, &ep);
       if (rv != VPPCOM_OK)
 	{
 	  errno = -rv;
@@ -1144,14 +1347,14 @@ ldp_copy_ep_to_sockaddr (__SOCKADDR_ARG addr, socklen_t * __restrict len,
 int
 getsockname (int fd, __SOCKADDR_ARG addr, socklen_t * __restrict len)
 {
-  vls_handle_t vlsh;
+  vcl_session_handle_t vclsh;
   int rv;
 
   if ((errno = -ldp_init ()))
     return -1;
 
-  vlsh = ldp_fd_to_vlsh (fd);
-  if (vlsh != VLS_INVALID_HANDLE)
+  vclsh = ldp_fd_to_vclsh (fd);
+  if (vclsh != INVALID_SESSION_ID)
     {
       vppcom_endpt_t ep;
       u8 addr_buf[sizeof (struct in6_addr)];
@@ -1159,7 +1362,7 @@ getsockname (int fd, __SOCKADDR_ARG addr, socklen_t * __restrict len)
 
       ep.ip = addr_buf;
 
-      rv = vls_attr (vlsh, VPPCOM_ATTR_GET_LCL_ADDR, &ep, &size);
+      rv = vppcom_session_attr (vclsh, VPPCOM_ATTR_GET_LCL_ADDR, &ep, &size);
       if (rv != VPPCOM_OK)
 	{
 	  errno = -rv;
@@ -1186,7 +1389,7 @@ getsockname (int fd, __SOCKADDR_ARG addr, socklen_t * __restrict len)
 int
 connect (int fd, __CONST_SOCKADDR_ARG addr, socklen_t len)
 {
-  vls_handle_t vlsh;
+  vcl_session_handle_t vclsh;
   int rv;
 
   if ((errno = -ldp_init ()))
@@ -1200,8 +1403,8 @@ connect (int fd, __CONST_SOCKADDR_ARG addr, socklen_t len)
       goto done;
     }
 
-  vlsh = ldp_fd_to_vlsh (fd);
-  if (vlsh != VLS_INVALID_HANDLE)
+  vclsh = ldp_fd_to_vclsh (fd);
+  if (vclsh != INVALID_SESSION_ID)
     {
       vppcom_endpt_t ep;
 
@@ -1210,8 +1413,8 @@ connect (int fd, __CONST_SOCKADDR_ARG addr, socklen_t len)
 	case AF_INET:
 	  if (len != sizeof (struct sockaddr_in))
 	    {
-	      LDBG (0, "fd %d: ERROR vlsh %u: Invalid AF_INET addr len %u!",
-		    fd, vlsh, len);
+	      LDBG (0, "fd %d: ERROR vclsh %u: Invalid AF_INET addr len %u!",
+		    fd, vclsh, len);
 	      errno = EINVAL;
 	      rv = -1;
 	      goto done;
@@ -1224,8 +1427,8 @@ connect (int fd, __CONST_SOCKADDR_ARG addr, socklen_t len)
 	case AF_INET6:
 	  if (len != sizeof (struct sockaddr_in6))
 	    {
-	      LDBG (0, "fd %d: ERROR vlsh %u: Invalid AF_INET6 addr len %u!",
-		    fd, vlsh, len);
+	      LDBG (0, "fd %d: ERROR vclsh %u: Invalid AF_INET6 addr len %u!",
+		    fd, vclsh, len);
 	      errno = EINVAL;
 	      rv = -1;
 	      goto done;
@@ -1236,16 +1439,17 @@ connect (int fd, __CONST_SOCKADDR_ARG addr, socklen_t len)
 	  break;
 
 	default:
-	  LDBG (0, "fd %d: ERROR vlsh %u: Unsupported address family %u!",
-		fd, vlsh, addr->sa_family);
+	  LDBG (0, "fd %d: ERROR vclsh %u: Unsupported address family %u!",
+		fd, vclsh, addr->sa_family);
 	  errno = EAFNOSUPPORT;
 	  rv = -1;
 	  goto done;
 	}
-      LDBG (0, "fd %d: calling vls_connect(): vlsh %u addr %p len %u", fd,
-	    vlsh, addr, len);
+      LDBG (0,
+	    "fd %d: calling vppcom_session_connect(): vclsh %u addr %p len %u",
+	    fd, vclsh, addr, len);
 
-      rv = vls_connect (vlsh, &ep);
+      rv = vppcom_session_connect (vclsh, &ep);
       if (rv != VPPCOM_OK)
 	{
 	  errno = -rv;
@@ -1268,21 +1472,21 @@ done:
 int
 getpeername (int fd, __SOCKADDR_ARG addr, socklen_t * __restrict len)
 {
-  vls_handle_t vlsh;
+  vcl_session_handle_t vclsh;
   int rv;
 
   if ((errno = -ldp_init ()))
     return -1;
 
-  vlsh = ldp_fd_to_vlsh (fd);
-  if (vlsh != VLS_INVALID_HANDLE)
+  vclsh = ldp_fd_to_vclsh (fd);
+  if (vclsh != INVALID_SESSION_ID)
     {
       vppcom_endpt_t ep;
       u8 addr_buf[sizeof (struct in6_addr)];
       u32 size = sizeof (ep);
 
       ep.ip = addr_buf;
-      rv = vls_attr (vlsh, VPPCOM_ATTR_GET_PEER_ADDR, &ep, &size);
+      rv = vppcom_session_attr (vclsh, VPPCOM_ATTR_GET_PEER_ADDR, &ep, &size);
       if (rv != VPPCOM_OK)
 	{
 	  errno = -rv;
@@ -1309,15 +1513,15 @@ getpeername (int fd, __SOCKADDR_ARG addr, socklen_t * __restrict len)
 ssize_t
 send (int fd, const void *buf, size_t n, int flags)
 {
-  vls_handle_t vlsh = ldp_fd_to_vlsh (fd);
+  vcl_session_handle_t vclsh = ldp_fd_to_vclsh (fd);
   ssize_t size;
 
   if ((errno = -ldp_init ()))
     return -1;
 
-  if (vlsh != VLS_INVALID_HANDLE)
+  if (vclsh != INVALID_SESSION_ID)
     {
-      size = vls_sendto (vlsh, (void *) buf, n, flags, NULL);
+      size = vppcom_session_sendto (vclsh, (void *) buf, n, flags, NULL);
       if (size < VPPCOM_OK)
 	{
 	  errno = -size;
@@ -1336,14 +1540,14 @@ ssize_t
 sendfile (int out_fd, int in_fd, off_t * offset, size_t len)
 {
   ldp_worker_ctx_t *ldpw = ldp_worker_get_current ();
-  vls_handle_t vlsh;
+  vcl_session_handle_t vclsh;
   ssize_t size = 0;
 
   if ((errno = -ldp_init ()))
     return -1;
 
-  vlsh = ldp_fd_to_vlsh (out_fd);
-  if (vlsh != VLS_INVALID_HANDLE)
+  vclsh = ldp_fd_to_vclsh (out_fd);
+  if (vclsh != INVALID_SESSION_ID)
     {
       int rv;
       ssize_t results = 0;
@@ -1353,11 +1557,14 @@ sendfile (int out_fd, int in_fd, off_t * offset, size_t len)
       u8 eagain = 0;
       u32 flags, flags_len = sizeof (flags);
 
-      rv = vls_attr (vlsh, VPPCOM_ATTR_GET_FLAGS, &flags, &flags_len);
+      rv =
+	vppcom_session_attr (vclsh, VPPCOM_ATTR_GET_FLAGS, &flags,
+			     &flags_len);
       if (PREDICT_FALSE (rv != VPPCOM_OK))
 	{
-	  LDBG (0, "ERROR: out fd %d: vls_attr: vlsh %u, returned %d (%s)!",
-		out_fd, vlsh, rv, vppcom_retval_str (rv));
+	  LDBG (0,
+		"ERROR: out fd %d: vppcom_session_attr: vclsh %u, returned %d (%s)!",
+		out_fd, vclsh, rv, vppcom_retval_str (rv));
 
 	  vec_reset_length (ldpw->io_buffer);
 	  errno = -rv;
@@ -1379,11 +1586,12 @@ sendfile (int out_fd, int in_fd, off_t * offset, size_t len)
 
       do
 	{
-	  size = vls_attr (vlsh, VPPCOM_ATTR_GET_NWRITE, 0, 0);
+	  size = vppcom_session_attr (vclsh, VPPCOM_ATTR_GET_NWRITE, 0, 0);
 	  if (size < 0)
 	    {
-	      LDBG (0, "ERROR: fd %d: vls_attr: vlsh %u returned %d (%s)!",
-		    out_fd, vlsh, size, vppcom_retval_str (size));
+	      LDBG (0,
+		    "ERROR: fd %d: voocom_session_attr: vclsh %u returned %d (%s)!",
+		    out_fd, vclsh, size, vppcom_retval_str (size));
 	      vec_reset_length (ldpw->io_buffer);
 	      errno = -size;
 	      size = -1;
@@ -1416,7 +1624,7 @@ sendfile (int out_fd, int in_fd, off_t * offset, size_t len)
 	      goto update_offset;
 	    }
 
-	  size = vls_write (vlsh, ldpw->io_buffer, nbytes);
+	  size = vppcom_session_write (vclsh, ldpw->io_buffer, nbytes);
 	  if (size < 0)
 	    {
 	      if (size == VPPCOM_EAGAIN)
@@ -1486,16 +1694,16 @@ sendfile64 (int out_fd, int in_fd, off_t * offset, size_t len)
 ssize_t
 recv (int fd, void *buf, size_t n, int flags)
 {
-  vls_handle_t vlsh;
+  vcl_session_handle_t vclsh;
   ssize_t size;
 
   if ((errno = -ldp_init ()))
     return -1;
 
-  vlsh = ldp_fd_to_vlsh (fd);
-  if (vlsh != VLS_INVALID_HANDLE)
+  vclsh = ldp_fd_to_vclsh (fd);
+  if (vclsh != INVALID_SESSION_ID)
     {
-      size = vls_recvfrom (vlsh, buf, n, flags, NULL);
+      size = vppcom_session_recvfrom (vclsh, buf, n, flags, NULL);
       if (size < 0)
 	errno = -size;
     }
@@ -1511,14 +1719,14 @@ ssize_t
 sendto (int fd, const void *buf, size_t n, int flags,
 	__CONST_SOCKADDR_ARG addr, socklen_t addr_len)
 {
-  vls_handle_t vlsh;
+  vcl_session_handle_t vclsh;
   ssize_t size;
 
   if ((errno = -ldp_init ()))
     return -1;
 
-  vlsh = ldp_fd_to_vlsh (fd);
-  if (vlsh != INVALID_SESSION_ID)
+  vclsh = ldp_fd_to_vclsh (fd);
+  if (vclsh != INVALID_SESSION_ID)
     {
       vppcom_endpt_t *ep = 0;
       vppcom_endpt_t _ep;
@@ -1551,7 +1759,7 @@ sendto (int fd, const void *buf, size_t n, int flags,
 	    }
 	}
 
-      size = vls_sendto (vlsh, (void *) buf, n, flags, ep);
+      size = vppcom_session_sendto (vclsh, (void *) buf, n, flags, ep);
       if (size < 0)
 	{
 	  errno = -size;
@@ -1571,14 +1779,14 @@ ssize_t
 recvfrom (int fd, void *__restrict buf, size_t n, int flags,
 	  __SOCKADDR_ARG addr, socklen_t * __restrict addr_len)
 {
-  vls_handle_t sid;
+  vcl_session_handle_t sid;
   ssize_t size, rv;
 
   if ((errno = -ldp_init ()))
     return -1;
 
-  sid = ldp_fd_to_vlsh (fd);
-  if (sid != VLS_INVALID_HANDLE)
+  sid = ldp_fd_to_vclsh (fd);
+  if (sid != INVALID_SESSION_ID)
     {
       vppcom_endpt_t ep;
       u8 src_addr[sizeof (struct sockaddr_in6)];
@@ -1586,7 +1794,7 @@ recvfrom (int fd, void *__restrict buf, size_t n, int flags,
       if (addr)
 	{
 	  ep.ip = src_addr;
-	  size = vls_recvfrom (sid, buf, n, flags, &ep);
+	  size = vppcom_session_recvfrom (sid, buf, n, flags, &ep);
 
 	  if (size > 0)
 	    {
@@ -1596,7 +1804,7 @@ recvfrom (int fd, void *__restrict buf, size_t n, int flags,
 	    }
 	}
       else
-	size = vls_recvfrom (sid, buf, n, flags, NULL);
+	size = vppcom_session_recvfrom (sid, buf, n, flags, NULL);
 
       if (size < 0)
 	{
@@ -1615,14 +1823,14 @@ recvfrom (int fd, void *__restrict buf, size_t n, int flags,
 ssize_t
 sendmsg (int fd, const struct msghdr * message, int flags)
 {
-  vls_handle_t vlsh;
+  vcl_session_handle_t vclsh;
   ssize_t size;
 
   if ((errno = -ldp_init ()))
     return -1;
 
-  vlsh = ldp_fd_to_vlsh (fd);
-  if (vlsh != VLS_INVALID_HANDLE)
+  vclsh = ldp_fd_to_vclsh (fd);
+  if (vclsh != INVALID_SESSION_ID)
     {
       LDBG (0, "LDP-TBD");
       errno = ENOSYS;
@@ -1642,7 +1850,7 @@ sendmmsg (int fd, struct mmsghdr *vmessages, unsigned int vlen, int flags)
 {
   ssize_t size;
   const char *func_str;
-  u32 sh = ldp_fd_to_vlsh (fd);
+  u32 sh = ldp_fd_to_vclsh (fd);
 
   if ((errno = -ldp_init ()))
     return -1;
@@ -1687,14 +1895,14 @@ sendmmsg (int fd, struct mmsghdr *vmessages, unsigned int vlen, int flags)
 ssize_t
 recvmsg (int fd, struct msghdr * message, int flags)
 {
-  vls_handle_t vlsh;
+  vcl_session_handle_t vclsh;
   ssize_t size;
 
   if ((errno = -ldp_init ()))
     return -1;
 
-  vlsh = ldp_fd_to_vlsh (fd);
-  if (vlsh != VLS_INVALID_HANDLE)
+  vclsh = ldp_fd_to_vclsh (fd);
+  if (vclsh != INVALID_SESSION_ID)
     {
       LDBG (0, "LDP-TBD");
       errno = ENOSYS;
@@ -1715,7 +1923,7 @@ recvmmsg (int fd, struct mmsghdr *vmessages,
 {
   ssize_t size;
   const char *func_str;
-  u32 sh = ldp_fd_to_vlsh (fd);
+  u32 sh = ldp_fd_to_vclsh (fd);
 
   if ((errno = -ldp_init ()))
     return -1;
@@ -1762,14 +1970,14 @@ int
 getsockopt (int fd, int level, int optname,
 	    void *__restrict optval, socklen_t * __restrict optlen)
 {
-  vls_handle_t vlsh;
+  vcl_session_handle_t vclsh;
   int rv;
 
   if ((errno = -ldp_init ()))
     return -1;
 
-  vlsh = ldp_fd_to_vlsh (fd);
-  if (vlsh != VLS_INVALID_HANDLE)
+  vclsh = ldp_fd_to_vclsh (fd);
+  if (vclsh != INVALID_SESSION_ID)
     {
       rv = -EOPNOTSUPP;
 
@@ -1779,26 +1987,26 @@ getsockopt (int fd, int level, int optname,
 	  switch (optname)
 	    {
 	    case TCP_NODELAY:
-	      rv = vls_attr (vlsh, VPPCOM_ATTR_GET_TCP_NODELAY,
-			     optval, optlen);
+	      rv = vppcom_session_attr (vclsh, VPPCOM_ATTR_GET_TCP_NODELAY,
+					optval, optlen);
 	      break;
 	    case TCP_MAXSEG:
-	      rv = vls_attr (vlsh, VPPCOM_ATTR_GET_TCP_USER_MSS,
-			     optval, optlen);
+	      rv = vppcom_session_attr (vclsh, VPPCOM_ATTR_GET_TCP_USER_MSS,
+					optval, optlen);
 	      break;
 	    case TCP_KEEPIDLE:
-	      rv = vls_attr (vlsh, VPPCOM_ATTR_GET_TCP_KEEPIDLE,
-			     optval, optlen);
+	      rv = vppcom_session_attr (vclsh, VPPCOM_ATTR_GET_TCP_KEEPIDLE,
+					optval, optlen);
 	      break;
 	    case TCP_KEEPINTVL:
-	      rv = vls_attr (vlsh, VPPCOM_ATTR_GET_TCP_KEEPINTVL,
-			     optval, optlen);
+	      rv = vppcom_session_attr (vclsh, VPPCOM_ATTR_GET_TCP_KEEPINTVL,
+					optval, optlen);
 	      break;
 	    case TCP_INFO:
 	      if (optval && optlen && (*optlen == sizeof (struct tcp_info)))
 		{
-		  LDBG (1, "fd %d: vlsh %u SOL_TCP, TCP_INFO, optval %p, "
-			"optlen %d: #LDP-NOP#", fd, vlsh, optval, *optlen);
+		  LDBG (1, "fd %d: vclsh %u SOL_TCP, TCP_INFO, optval %p, "
+			"optlen %d: #LDP-NOP#", fd, vclsh, optval, *optlen);
 		  memset (optval, 0, *optlen);
 		  rv = VPPCOM_OK;
 		}
@@ -1812,7 +2020,7 @@ getsockopt (int fd, int level, int optname,
 	      break;
 	    default:
 	      LDBG (0, "ERROR: fd %d: getsockopt SOL_TCP: sid %u, "
-		    "optname %d unsupported!", fd, vlsh, optname);
+		    "optname %d unsupported!", fd, vclsh, optname);
 	      break;
 	    }
 	  break;
@@ -1820,11 +2028,13 @@ getsockopt (int fd, int level, int optname,
 	  switch (optname)
 	    {
 	    case IPV6_V6ONLY:
-	      rv = vls_attr (vlsh, VPPCOM_ATTR_GET_V6ONLY, optval, optlen);
+	      rv =
+		vppcom_session_attr (vclsh, VPPCOM_ATTR_GET_V6ONLY, optval,
+				     optlen);
 	      break;
 	    default:
-	      LDBG (0, "ERROR: fd %d: getsockopt SOL_IPV6: vlsh %u "
-		    "optname %d unsupported!", fd, vlsh, optname);
+	      LDBG (0, "ERROR: fd %d: getsockopt SOL_IPV6: vclsh %u "
+		    "optname %d unsupported!", fd, vclsh, optname);
 	      break;
 	    }
 	  break;
@@ -1832,35 +2042,47 @@ getsockopt (int fd, int level, int optname,
 	  switch (optname)
 	    {
 	    case SO_ACCEPTCONN:
-	      rv = vls_attr (vlsh, VPPCOM_ATTR_GET_LISTEN, optval, optlen);
+	      rv =
+		vppcom_session_attr (vclsh, VPPCOM_ATTR_GET_LISTEN, optval,
+				     optlen);
 	      break;
 	    case SO_KEEPALIVE:
-	      rv = vls_attr (vlsh, VPPCOM_ATTR_GET_KEEPALIVE, optval, optlen);
+	      rv =
+		vppcom_session_attr (vclsh, VPPCOM_ATTR_GET_KEEPALIVE, optval,
+				     optlen);
 	      break;
 	    case SO_PROTOCOL:
-	      rv = vls_attr (vlsh, VPPCOM_ATTR_GET_PROTOCOL, optval, optlen);
+	      rv =
+		vppcom_session_attr (vclsh, VPPCOM_ATTR_GET_PROTOCOL, optval,
+				     optlen);
 	      *(int *) optval = *(int *) optval ? SOCK_DGRAM : SOCK_STREAM;
 	      break;
 	    case SO_SNDBUF:
-	      rv = vls_attr (vlsh, VPPCOM_ATTR_GET_TX_FIFO_LEN,
-			     optval, optlen);
+	      rv = vppcom_session_attr (vclsh, VPPCOM_ATTR_GET_TX_FIFO_LEN,
+					optval, optlen);
 	      break;
 	    case SO_RCVBUF:
-	      rv = vls_attr (vlsh, VPPCOM_ATTR_GET_RX_FIFO_LEN,
-			     optval, optlen);
+	      rv = vppcom_session_attr (vclsh, VPPCOM_ATTR_GET_RX_FIFO_LEN,
+					optval, optlen);
 	      break;
 	    case SO_REUSEADDR:
-	      rv = vls_attr (vlsh, VPPCOM_ATTR_GET_REUSEADDR, optval, optlen);
+	      rv =
+		vppcom_session_attr (vclsh, VPPCOM_ATTR_GET_REUSEADDR, optval,
+				     optlen);
 	      break;
 	    case SO_BROADCAST:
-	      rv = vls_attr (vlsh, VPPCOM_ATTR_GET_BROADCAST, optval, optlen);
+	      rv =
+		vppcom_session_attr (vclsh, VPPCOM_ATTR_GET_BROADCAST, optval,
+				     optlen);
 	      break;
 	    case SO_ERROR:
-	      rv = vls_attr (vlsh, VPPCOM_ATTR_GET_ERROR, optval, optlen);
+	      rv =
+		vppcom_session_attr (vclsh, VPPCOM_ATTR_GET_ERROR, optval,
+				     optlen);
 	      break;
 	    default:
-	      LDBG (0, "ERROR: fd %d: getsockopt SOL_SOCKET: vlsh %u "
-		    "optname %d unsupported!", fd, vlsh, optname);
+	      LDBG (0, "ERROR: fd %d: getsockopt SOL_SOCKET: vclsh %u "
+		    "optname %d unsupported!", fd, vclsh, optname);
 	      break;
 	    }
 	  break;
@@ -1886,14 +2108,14 @@ int
 setsockopt (int fd, int level, int optname,
 	    const void *optval, socklen_t optlen)
 {
-  vls_handle_t vlsh;
+  vcl_session_handle_t vclsh;
   int rv;
 
   if ((errno = -ldp_init ()))
     return -1;
 
-  vlsh = ldp_fd_to_vlsh (fd);
-  if (vlsh != VLS_INVALID_HANDLE)
+  vclsh = ldp_fd_to_vclsh (fd);
+  if (vclsh != INVALID_SESSION_ID)
     {
       rv = -EOPNOTSUPP;
 
@@ -1903,20 +2125,20 @@ setsockopt (int fd, int level, int optname,
 	  switch (optname)
 	    {
 	    case TCP_NODELAY:
-	      rv = vls_attr (vlsh, VPPCOM_ATTR_SET_TCP_NODELAY,
-			     (void *) optval, &optlen);
+	      rv = vppcom_session_attr (vclsh, VPPCOM_ATTR_SET_TCP_NODELAY,
+					(void *) optval, &optlen);
 	      break;
 	    case TCP_MAXSEG:
-	      rv = vls_attr (vlsh, VPPCOM_ATTR_SET_TCP_USER_MSS,
-			     (void *) optval, &optlen);
+	      rv = vppcom_session_attr (vclsh, VPPCOM_ATTR_SET_TCP_USER_MSS,
+					(void *) optval, &optlen);
 	      break;
 	    case TCP_KEEPIDLE:
-	      rv = vls_attr (vlsh, VPPCOM_ATTR_SET_TCP_KEEPIDLE,
-			     (void *) optval, &optlen);
+	      rv = vppcom_session_attr (vclsh, VPPCOM_ATTR_SET_TCP_KEEPIDLE,
+					(void *) optval, &optlen);
 	      break;
 	    case TCP_KEEPINTVL:
-	      rv = vls_attr (vlsh, VPPCOM_ATTR_SET_TCP_KEEPINTVL,
-			     (void *) optval, &optlen);
+	      rv = vppcom_session_attr (vclsh, VPPCOM_ATTR_SET_TCP_KEEPINTVL,
+					(void *) optval, &optlen);
 	      break;
 	    case TCP_CONGESTION:
 	    case TCP_CORK:
@@ -1924,8 +2146,8 @@ setsockopt (int fd, int level, int optname,
 	      rv = 0;
 	      break;
 	    default:
-	      LDBG (0, "ERROR: fd %d: setsockopt() SOL_TCP: vlsh %u"
-		    "optname %d unsupported!", fd, vlsh, optname);
+	      LDBG (0, "ERROR: fd %d: setsockopt() SOL_TCP: vclsh %u"
+		    "optname %d unsupported!", fd, vclsh, optname);
 	      break;
 	    }
 	  break;
@@ -1933,12 +2155,12 @@ setsockopt (int fd, int level, int optname,
 	  switch (optname)
 	    {
 	    case IPV6_V6ONLY:
-	      rv = vls_attr (vlsh, VPPCOM_ATTR_SET_V6ONLY,
-			     (void *) optval, &optlen);
+	      rv = vppcom_session_attr (vclsh, VPPCOM_ATTR_SET_V6ONLY,
+					(void *) optval, &optlen);
 	      break;
 	    default:
-	      LDBG (0, "ERROR: fd %d: setsockopt SOL_IPV6: vlsh %u"
-		    "optname %d unsupported!", fd, vlsh, optname);
+	      LDBG (0, "ERROR: fd %d: setsockopt SOL_IPV6: vclsh %u"
+		    "optname %d unsupported!", fd, vclsh, optname);
 	      break;
 	    }
 	  break;
@@ -1946,20 +2168,20 @@ setsockopt (int fd, int level, int optname,
 	  switch (optname)
 	    {
 	    case SO_KEEPALIVE:
-	      rv = vls_attr (vlsh, VPPCOM_ATTR_SET_KEEPALIVE,
-			     (void *) optval, &optlen);
+	      rv = vppcom_session_attr (vclsh, VPPCOM_ATTR_SET_KEEPALIVE,
+					(void *) optval, &optlen);
 	      break;
 	    case SO_REUSEADDR:
-	      rv = vls_attr (vlsh, VPPCOM_ATTR_SET_REUSEADDR,
-			     (void *) optval, &optlen);
+	      rv = vppcom_session_attr (vclsh, VPPCOM_ATTR_SET_REUSEADDR,
+					(void *) optval, &optlen);
 	      break;
 	    case SO_BROADCAST:
-	      rv = vls_attr (vlsh, VPPCOM_ATTR_SET_BROADCAST,
-			     (void *) optval, &optlen);
+	      rv = vppcom_session_attr (vclsh, VPPCOM_ATTR_SET_BROADCAST,
+					(void *) optval, &optlen);
 	      break;
 	    default:
-	      LDBG (0, "ERROR: fd %d: setsockopt SOL_SOCKET: vlsh %u "
-		    "optname %d unsupported!", fd, vlsh, optname);
+	      LDBG (0, "ERROR: fd %d: setsockopt SOL_SOCKET: vclsh %u "
+		    "optname %d unsupported!", fd, vclsh, optname);
 	      break;
 	    }
 	  break;
@@ -1984,18 +2206,20 @@ setsockopt (int fd, int level, int optname,
 int
 listen (int fd, int n)
 {
-  vls_handle_t vlsh;
+  vcl_session_handle_t vclsh;
+  vcl_worker_t *wrk = vcl_worker_get_current ();
   int rv;
 
   if ((errno = -ldp_init ()))
     return -1;
 
-  vlsh = ldp_fd_to_vlsh (fd);
-  if (vlsh != VLS_INVALID_HANDLE)
+  vclsh = ldp_fd_to_vclsh (fd);
+  if (vclsh != INVALID_SESSION_ID)
     {
-      LDBG (0, "fd %d: calling vls_listen: vlsh %u, n %d", fd, vlsh, n);
+      LDBG (0, "fd %d: calling vppcom_session_listen: vclsh %u, n %d", fd,
+	    vclsh, n);
 
-      rv = vls_listen (vlsh, n);
+      rv = vppcom_session_listen (vclsh, n);
       if (rv != VPPCOM_OK)
 	{
 	  errno = -rv;
@@ -2009,6 +2233,10 @@ listen (int fd, int n)
     }
 
   LDBG (1, "fd %d: returning %d", fd, rv);
+/*Update listen info in vcl worker*/
+  wrk->listen_fd = fd;
+  wrk->listen_queue_size = n;
+  wrk->listen_session_index = vppcom_session_index (vclsh);
   return rv;
 }
 
@@ -2016,14 +2244,14 @@ static inline int
 ldp_accept4 (int listen_fd, __SOCKADDR_ARG addr,
 	     socklen_t * __restrict addr_len, int flags)
 {
-  vls_handle_t listen_vlsh, accept_vlsh;
+  vcl_session_handle_t listen_vclsh, accept_vclsh;
   int rv;
 
   if ((errno = -ldp_init ()))
     return -1;
 
-  listen_vlsh = ldp_fd_to_vlsh (listen_fd);
-  if (listen_vlsh != VLS_INVALID_HANDLE)
+  listen_vclsh = ldp_fd_to_vclsh (listen_fd);
+  if (listen_vclsh != INVALID_SESSION_ID)
     {
       vppcom_endpt_t ep;
       u8 src_addr[sizeof (struct sockaddr_in6)];
@@ -2031,12 +2259,12 @@ ldp_accept4 (int listen_fd, __SOCKADDR_ARG addr,
       ep.ip = src_addr;
 
       LDBG (0, "listen fd %d: calling vppcom_session_accept: listen sid %u,"
-	    " ep %p, flags 0x%x", listen_fd, listen_vlsh, ep, flags);
+	    " ep %p, flags 0x%x", listen_fd, listen_vclsh, ep, flags);
 
-      accept_vlsh = vls_accept (listen_vlsh, &ep, flags);
-      if (accept_vlsh < 0)
+      accept_vclsh = vppcom_session_accept (listen_vclsh, &ep, flags);
+      if (accept_vclsh < 0)
 	{
-	  errno = -accept_vlsh;
+	  errno = -accept_vclsh;
 	  rv = -1;
 	}
       else
@@ -2044,13 +2272,13 @@ ldp_accept4 (int listen_fd, __SOCKADDR_ARG addr,
 	  rv = ldp_copy_ep_to_sockaddr (addr, addr_len, &ep);
 	  if (rv != VPPCOM_OK)
 	    {
-	      (void) vls_close (accept_vlsh);
+	      (void) vppcom_session_close (accept_vclsh);
 	      errno = -rv;
 	      rv = -1;
 	    }
 	  else
 	    {
-	      rv = ldp_vlsh_to_fd (accept_vlsh);
+	      rv = ldp_vclsh_to_fd (accept_vclsh);
 	    }
 	}
     }
@@ -2083,25 +2311,26 @@ accept (int fd, __SOCKADDR_ARG addr, socklen_t * __restrict addr_len)
 int
 shutdown (int fd, int how)
 {
-  vls_handle_t vlsh;
+  vcl_session_handle_t vclsh;
   int rv = 0, flags;
   u32 flags_len = sizeof (flags);
 
   if ((errno = -ldp_init ()))
     return -1;
 
-  vlsh = ldp_fd_to_vlsh (fd);
-  if (vlsh != VLS_INVALID_HANDLE)
+  vclsh = ldp_fd_to_vclsh (fd);
+  if (vclsh != INVALID_SESSION_ID)
     {
-      LDBG (0, "called shutdown: fd %u vlsh %u how %d", fd, vlsh, how);
+      LDBG (0, "called shutdown: fd %u vclsh %u how %d", fd, vclsh, how);
 
-      if (vls_attr (vlsh, VPPCOM_ATTR_SET_SHUT, &how, &flags_len))
+      if (vppcom_session_attr (vclsh, VPPCOM_ATTR_SET_SHUT, &how, &flags_len))
 	{
 	  close (fd);
 	  return -1;
 	}
 
-      if (vls_attr (vlsh, VPPCOM_ATTR_GET_SHUT, &flags, &flags_len))
+      if (vppcom_session_attr
+	  (vclsh, VPPCOM_ATTR_GET_SHUT, &flags, &flags_len))
 	{
 	  close (fd);
 	  return -1;
@@ -2123,7 +2352,7 @@ int
 epoll_create1 (int flags)
 {
   ldp_worker_ctx_t *ldpw = ldp_worker_get_current ();
-  vls_handle_t vlsh;
+  vcl_session_handle_t vclsh;
   int rv;
 
   if ((errno = -ldp_init ()))
@@ -2144,17 +2373,17 @@ epoll_create1 (int flags)
       return rv;
     }
 
-  vlsh = vls_epoll_create ();
-  if (PREDICT_FALSE (vlsh == VLS_INVALID_HANDLE))
+  vclsh = vppcom_epoll_create ();
+  if (PREDICT_FALSE (vclsh == INVALID_SESSION_ID))
     {
-      errno = -vlsh;
+      errno = -vclsh;
       rv = -1;
     }
   else
     {
-      rv = ldp_vlsh_to_fd (vlsh);
+      rv = ldp_vclsh_to_fd (vclsh);
     }
-  LDBG (0, "epoll_create epfd %u vlsh %u", rv, vlsh);
+  LDBG (0, "epoll_create epfd %u vclsh %u", rv, vclsh);
   return rv;
 }
 
@@ -2167,14 +2396,14 @@ epoll_create (int size)
 int
 epoll_ctl (int epfd, int op, int fd, struct epoll_event *event)
 {
-  vls_handle_t vep_vlsh, vlsh;
+  vcl_session_handle_t vep_vclsh, vclsh;
   int rv;
 
   if ((errno = -ldp_init ()))
     return -1;
 
-  vep_vlsh = ldp_fd_to_vlsh (epfd);
-  if (PREDICT_FALSE (vep_vlsh == VLS_INVALID_HANDLE))
+  vep_vclsh = ldp_fd_to_vclsh (epfd);
+  if (PREDICT_FALSE (vep_vclsh == INVALID_SESSION_ID))
     {
       /* The LDP epoll_create1 always creates VCL epfd's.
        * The app should never have a kernel base epoll fd unless it
@@ -2188,17 +2417,18 @@ epoll_ctl (int epfd, int op, int fd, struct epoll_event *event)
       goto done;
     }
 
-  vlsh = ldp_fd_to_vlsh (fd);
+  vclsh = ldp_fd_to_vclsh (fd);
 
-  LDBG (0, "epfd %d ep_vlsh %d, fd %u vlsh %d, op %u", epfd, vep_vlsh, fd,
-	vlsh, op);
+  LDBG (0, "epfd %d ep_vclsh %d, fd %u vclsh %d, op %u", epfd, vep_vclsh, fd,
+	vclsh, op);
 
-  if (vlsh != VLS_INVALID_HANDLE)
+  if (vclsh != INVALID_SESSION_ID)
     {
-      LDBG (1, "epfd %d: calling vls_epoll_ctl: ep_vlsh %d op %d, vlsh %u,"
-	    " event %p", epfd, vep_vlsh, vlsh, event);
+      LDBG (1,
+	    "epfd %d: calling vppcom_epoll_ctl: ep_vclsh %d op %d, vclsh %u,"
+	    " event %p", epfd, vep_vclsh, vclsh, event);
 
-      rv = vls_epoll_ctl (vep_vlsh, op, vlsh, event);
+      rv = vppcom_epoll_ctl (vep_vclsh, op, vclsh, event);
       if (rv != VPPCOM_OK)
 	{
 	  errno = -rv;
@@ -2210,11 +2440,12 @@ epoll_ctl (int epfd, int op, int fd, struct epoll_event *event)
       int libc_epfd;
       u32 size = sizeof (epfd);
 
-      libc_epfd = vls_attr (vep_vlsh, VPPCOM_ATTR_GET_LIBC_EPFD, 0, 0);
+      libc_epfd =
+	vppcom_session_attr (vep_vclsh, VPPCOM_ATTR_GET_LIBC_EPFD, 0, 0);
       if (!libc_epfd)
 	{
-	  LDBG (1, "epfd %d, vep_vlsh %d calling libc_epoll_create1: "
-		"EPOLL_CLOEXEC", epfd, vep_vlsh);
+	  LDBG (1, "epfd %d, vep_vclsh %d calling libc_epoll_create1: "
+		"EPOLL_CLOEXEC", epfd, vep_vclsh);
 
 	  libc_epfd = libc_epoll_create1 (EPOLL_CLOEXEC);
 	  if (libc_epfd < 0)
@@ -2223,8 +2454,9 @@ epoll_ctl (int epfd, int op, int fd, struct epoll_event *event)
 	      goto done;
 	    }
 
-	  rv = vls_attr (vep_vlsh, VPPCOM_ATTR_SET_LIBC_EPFD, &libc_epfd,
-			 &size);
+	  rv =
+	    vppcom_session_attr (vep_vclsh, VPPCOM_ATTR_SET_LIBC_EPFD,
+				 &libc_epfd, &size);
 	  if (rv < 0)
 	    {
 	      errno = -rv;
@@ -2256,7 +2488,7 @@ ldp_epoll_pwait (int epfd, struct epoll_event *events, int maxevents,
   ldp_worker_ctx_t *ldpw = ldp_worker_get_current ();
   double time_to_wait = (double) 0, max_time;
   int libc_epfd, rv = 0;
-  vls_handle_t ep_vlsh;
+  vcl_session_handle_t ep_vclsh;
 
   if ((errno = -ldp_init ()))
     return -1;
@@ -2270,10 +2502,10 @@ ldp_epoll_pwait (int epfd, struct epoll_event *events, int maxevents,
   if (epfd == ldpw->vcl_mq_epfd)
     return libc_epoll_pwait (epfd, events, maxevents, timeout, sigmask);
 
-  ep_vlsh = ldp_fd_to_vlsh (epfd);
-  if (PREDICT_FALSE (ep_vlsh == VLS_INVALID_HANDLE))
+  ep_vclsh = ldp_fd_to_vclsh (epfd);
+  if (PREDICT_FALSE (ep_vclsh == INVALID_SESSION_ID))
     {
-      LDBG (0, "epfd %d: bad ep_vlsh %d!", epfd, ep_vlsh);
+      LDBG (0, "epfd %d: bad ep_vclsh %d!", epfd, ep_vclsh);
       errno = EBADFD;
       return -1;
     }
@@ -2283,7 +2515,7 @@ ldp_epoll_pwait (int epfd, struct epoll_event *events, int maxevents,
   time_to_wait = ((timeout >= 0) ? (double) timeout / 1000 : 0);
   max_time = clib_time_now (&ldpw->clib_time) + time_to_wait;
 
-  libc_epfd = vls_attr (ep_vlsh, VPPCOM_ATTR_GET_LIBC_EPFD, 0, 0);
+  libc_epfd = vppcom_session_attr (ep_vclsh, VPPCOM_ATTR_GET_LIBC_EPFD, 0, 0);
   if (PREDICT_FALSE (libc_epfd < 0))
     {
       errno = -libc_epfd;
@@ -2292,13 +2524,13 @@ ldp_epoll_pwait (int epfd, struct epoll_event *events, int maxevents,
     }
 
   LDBG (2, "epfd %d: vep_idx %d, libc_epfd %d, events %p, maxevents %d, "
-	"timeout %d, sigmask %p: time_to_wait %.02f", epfd, ep_vlsh,
+	"timeout %d, sigmask %p: time_to_wait %.02f", epfd, ep_vclsh,
 	libc_epfd, events, maxevents, timeout, sigmask, time_to_wait);
   do
     {
       if (!ldpw->epoll_wait_vcl)
 	{
-	  rv = vls_epoll_wait (ep_vlsh, events, maxevents, 0);
+	  rv = vppcom_epoll_wait (ep_vclsh, events, maxevents, 0);
 	  if (rv > 0)
 	    {
 	      ldpw->epoll_wait_vcl = 1;
@@ -2345,7 +2577,7 @@ poll (struct pollfd *fds, nfds_t nfds, int timeout)
 {
   ldp_worker_ctx_t *ldpw = ldp_worker_get_current ();
   int rv, i, n_revents = 0;
-  vls_handle_t vlsh;
+  vcl_session_handle_t vclsh;
   vcl_poll_t *vp;
   double max_time;
 
@@ -2362,13 +2594,13 @@ poll (struct pollfd *fds, nfds_t nfds, int timeout)
       if (fds[i].fd < 0)
 	continue;
 
-      vlsh = ldp_fd_to_vlsh (fds[i].fd);
-      if (vlsh != VLS_INVALID_HANDLE)
+      vclsh = ldp_fd_to_vclsh (fds[i].fd);
+      if (vclsh != INVALID_SESSION_ID)
 	{
 	  fds[i].fd = -fds[i].fd;
 	  vec_add2 (ldpw->vcl_poll, vp, 1);
 	  vp->fds_ndx = i;
-	  vp->sh = vlsh_to_sh (vlsh);
+	  vp->sh = vclsh;
 	  vp->events = fds[i].events;
 #ifdef __USE_XOPEN2K
 	  if (fds[i].events & POLLRDNORM)
diff --git a/src/vcl/ldp.h b/src/vcl/ldp.h
index 8d78ead08..0a03f442d 100644
--- a/src/vcl/ldp.h
+++ b/src/vcl/ldp.h
@@ -34,7 +34,7 @@
 #define LDP_ENV_TLS_KEY   "LDP_TLS_KEY_FILE"
 #define LDP_ENV_TLS_TRANS "LDP_TRANSPARENT_TLS"
 
-#define LDP_SID_BIT_MIN   5
+#define LDP_SID_BIT_MIN   16
 #define LDP_SID_BIT_MAX   30
 
 #define LDP_APP_NAME_MAX  256
diff --git a/src/vcl/vcl_private.h b/src/vcl/vcl_private.h
index 8fdf7551c..16c23de82 100644
--- a/src/vcl/vcl_private.h
+++ b/src/vcl/vcl_private.h
@@ -238,7 +238,12 @@ typedef struct vcl_worker_
   /* Session pool */
   vcl_session_t *sessions;
 
-  /** Worker/thread index in current process */
+  u32 listen_session_index;
+
+  u32 listen_fd;
+
+  u32 listen_queue_size;
+/** Worker/thread index in current process */
   u32 wrk_index;
 
   /** Worker index in vpp*/
-- 
2.17.1

